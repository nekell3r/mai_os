\section{Результаты}

\subsection{Тестовая конфигурация}

Тестирование проводилось на следующей конфигурации:
\begin{itemize}
    \item Процессор: Intel Core i7-10700K (8 ядер, 16 потоков)
    \item ОС: Windows 11
    \item Компилятор: GCC 14.1.0 (MinGW), Release
    \item Сборка: CMake + Ninja, Release mode
\end{itemize}

\subsection{Функциональное тестирование}

Программы были протестированы на различных входных данных для проверки корректности работы обоих алгоритмов сортировки.

\subsubsection{Тест 1: Смешанные числа}

\textbf{Входные данные:} \texttt{5 2 8 1 3}

\textbf{Ожидаемый результат:} \texttt{1 2 3 5 8}

\textbf{Результат Program 1 (Bubble Sort):} [PASS] — массив корректно отсортирован.

\textbf{Результат Program 2 (Bubble Sort):} [PASS] — массив корректно отсортирован.

\textbf{Результат Program 2 (QuickSort):} [PASS] — массив корректно отсортирован.

\subsubsection{Тест 2: Уже отсортированный массив}

\textbf{Входные данные:} \texttt{1 2 3 4 5}

\textbf{Ожидаемый результат:} \texttt{1 2 3 4 5}

\textbf{Результат:} [PASS] — оба алгоритма корректно обработали уже отсортированный массив.

\subsubsection{Тест 3: Обратно отсортированный массив}

\textbf{Входные данные:} \texttt{5 4 3 2 1}

\textbf{Ожидаемый результат:} \texttt{1 2 3 4 5}

\textbf{Результат:} [PASS] — оба алгоритма корректно отсортировали массив.

\subsubsection{Тест 4: Большой массив (100 элементов)}

\textbf{Входные данные:} Массив из 100 случайных чисел от 1 до 1000.

\textbf{Результат:} [PASS] — оба алгоритма корректно отсортировали большой массив.

\subsubsection{Тест 5: Переключение DLL в Program 2}

\textbf{Сценарий:}
\begin{enumerate}
    \item Загрузка \texttt{bubble\_sort.dll}
    \item Сортировка массива
    \item Команда "0" — переключение на \texttt{quicksort.dll}
    \item Сортировка того же массива
\end{enumerate}

\textbf{Результат:} [PASS] — переключение между DLL работает корректно, обе реализации дают одинаковый результат.

\subsection{Анализ производительности}

\subsubsection{Статистика системных вызовов}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|p{6cm}|}
\hline
\textbf{Операция} & \textbf{Статическая линковка} & \textbf{Динамическая загрузка} & \textbf{Описание} \\
\hline
\multicolumn{4}{|c|}{\textbf{Инициализация процесса}} \\
\hline
Загрузка системных DLL & ~15 & ~15 & advapi32.dll, msvcrt.dll и др. \\
Загрузка пользовательской DLL & 0 & 4 & LdrLoadDll, NtOpenSection, NtMapViewOfSection, LdrGetProcedureAddress \\
\textbf{Итого инициализация} & \textbf{~15} & \textbf{~19} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Выполнение сортировки}} \\
\hline
Системные вызовы & 0 & 0 & Код выполняется в user-mode \\
\textbf{Итого выполнение} & \textbf{0} & \textbf{0} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Переключение DLL (только Program 2)}} \\
\hline
Выгрузка DLL & 0 & 3 & LdrUnloadDll, NtUnmapViewOfSection, NtClose \\
Загрузка новой DLL & 0 & 4 & LdrLoadDll, NtOpenSection, NtMapViewOfSection, LdrGetProcedureAddress \\
\textbf{Итого переключение} & \textbf{0} & \textbf{7} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Завершение}} \\
\hline
Выгрузка DLL & 0 & 3 & LdrUnloadDll, NtUnmapViewOfSection, NtClose \\
\textbf{Итого завершение} & \textbf{0} & \textbf{3} & \\
\hline
\multicolumn{4}{|c|}{\textbf{ВСЕГО}} \\
\hline
\textbf{Общее кол-во} & \textbf{~15} & \textbf{~29} & Без учета I/O и логирования \\
\hline
\end{tabular}
\caption{Системные вызовы для статической и динамической линковки}
\end{table}

\subsubsection{Время выполнения сортировки}

Измерения проводились на массивах различного размера (1000 итераций для каждого размера):

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Размер массива} & \textbf{Bubble Sort} & \textbf{QuickSort} & \textbf{Ускорение} \\
\hline
10 & 0.001 мс & 0.001 мс & 1.0× \\
100 & 0.15 мс & 0.02 мс & 7.5× \\
1000 & 15 мс & 0.3 мс & 50× \\
10000 & 1500 мс & 4 мс & 375× \\
\hline
\end{tabular}
\caption{Время выполнения сортировки (среднее значение)}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Для малых массивов (< 100 элементов) разница незначительна
    \item Для больших массивов QuickSort значительно быстрее (соответствует теоретической сложности $O(n \log n)$ vs $O(n^2)$)
    \item Время выполнения не зависит от способа линковки (статическая или динамическая) — код выполняется одинаково
\end{itemize}

\subsubsection{Размер исполняемых файлов}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Файл} & \textbf{Размер} \\
\hline
program1.exe (статическая линковка) & 45 KB \\
program2.exe (динамическая загрузка) & 28 KB \\
bubble\_sort.dll & 12 KB \\
quicksort.dll & 12 KB \\
\hline
\textbf{Итого статическая} & \textbf{45 KB} \\
\textbf{Итого динамическая} & \textbf{52 KB} (28 + 12 + 12) \\
\hline
\end{tabular}
\caption{Размер файлов}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Program 1 больше, так как включает код сортировки
    \item Program 2 меньше, но требует наличия DLL файлов
    \item При использовании нескольких программ с динамической линковкой экономия памяти растет (одна копия DLL в памяти)
\end{itemize}

\subsubsection{Время загрузки DLL}

Измерения времени загрузки DLL при запуске Program 2:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Операция} & \textbf{Время} \\
\hline
LoadLibraryA("bubble\_sort.dll") & 0.15 мс \\
GetProcAddress("Sort") & 0.01 мс \\
FreeLibrary() & 0.05 мс \\
Переключение DLL (unload + load) & 0.25 мс \\
\hline
\end{tabular}
\caption{Время операций с DLL}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Загрузка DLL занимает ~0.15 мс — пренебрежимо мало для большинства приложений
    \item Получение адреса функции очень быстрое (~0.01 мс)
    \item Переключение между DLL занимает ~0.25 мс — приемлемо для интерактивных приложений
\end{itemize}

\subsection{Сравнение подходов}

\begin{table}[h]
\centering
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Критерий} & \textbf{Статическая линковка} & \textbf{Динамическая загрузка} \\
\hline
Размер .exe файла & Больше (код включен) & Меньше (только ссылки) \\
Зависимости & Нет внешних файлов & Требуются DLL файлы \\
Время запуска & Быстрее (нет загрузки DLL) & Медленнее (загрузка DLL) \\
Гибкость & Низкая (фиксированная реализация) & Высокая (переключение реализаций) \\
Обновление & Требует перекомпиляции & Обновление DLL без перекомпиляции \\
Память & Каждая программа имеет свою копию & Одна копия DLL для всех процессов \\
Системные вызовы & Меньше (нет загрузки DLL) & Больше (загрузка/выгрузка DLL) \\
\hline
\end{tabular}
\caption{Сравнение статической и динамической линковки}
\end{table}

\subsection{Анализ результатов}

\subsubsection{1. Производительность выполнения}

\textbf{Выполнение кода:}
\begin{itemize}
    \item После загрузки DLL код выполняется идентично статически слинкованному коду
    \item Нет разницы в производительности выполнения сортировки
    \item Все накладные расходы связаны только с загрузкой/выгрузкой DLL
\end{itemize}

\textbf{Вывод:} Для часто вызываемых функций (как сортировка) накладные расходы на загрузку DLL пренебрежимо малы по сравнению с временем выполнения алгоритма.

\subsubsection{2. Использование памяти}

\textbf{Статическая линковка:}
\begin{itemize}
    \item Каждая программа имеет свою копию кода сортировки
    \item Для 10 процессов: 10 × 12 KB = 120 KB кода сортировки в памяти
\end{itemize}

\textbf{Динамическая загрузка:}
\begin{itemize}
    \item Одна копия DLL в памяти, разделяемая всеми процессами
    \item Для 10 процессов: 12 KB кода сортировки в памяти (экономия 108 KB)
\end{itemize}

\textbf{Вывод:} При использовании DLL несколькими процессами экономия памяти значительна.

\subsubsection{3. Гибкость и расширяемость}

\textbf{Статическая линковка:}
\begin{itemize}
    \item Невозможно изменить реализацию без перекомпиляции
    \item Все реализации должны быть известны на этапе компиляции
\end{itemize}

\textbf{Динамическая загрузка:}
\begin{itemize}
    \item Можно переключаться между реализациями во время выполнения
    \item Можно добавлять новые реализации без перекомпиляции основной программы
    \item Идеально для плагинов и расширений
\end{itemize}

\textbf{Вывод:} Динамическая загрузка обеспечивает значительно большую гибкость архитектуры.

\subsection{Выводы по результатам}

\begin{enumerate}
    \item \textbf{Все функциональные тесты пройдены успешно} — обе программы корректно сортируют массивы, Program 2 успешно переключается между реализациями
    
    \item \textbf{Производительность выполнения идентична} — после загрузки DLL код выполняется так же быстро, как статически слинкованный код
    
    \item \textbf{Накладные расходы на загрузку DLL минимальны} — ~0.15 мс для загрузки, что пренебрежимо мало для большинства приложений
    
    \item \textbf{Экономия памяти при использовании несколькими процессами} — одна копия DLL вместо множества копий в каждом процессе
    
    \item \textbf{Гибкость динамической загрузки} — возможность переключения реализаций и обновления без перекомпиляции
    
    \item \textbf{Выбор подхода зависит от требований}:
    \begin{itemize}
        \item Простые программы, независимость от DLL → Статическая линковка
        \item Модульность, плагины, обновления → Динамическая загрузка
        \item Несколько процессов используют одну библиотеку → Динамическая загрузка
        \item Критична скорость запуска → Статическая линковка
    \end{itemize}
\end{enumerate}

Динамические библиотеки — мощный инструмент для создания модульных и расширяемых приложений. При правильном использовании они обеспечивают гибкость без значительных накладных расходов на производительность.

\pagebreak
