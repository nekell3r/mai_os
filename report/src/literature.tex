\section{Исходная программа}

\subsection{Интерфейс}

\subsubsection{sort\_interface.h}

\lstinputlisting[language=C++,caption=sort\_interface.h,basicstyle=\tiny\ttfamily]{inc/sort_interface.h}

\subsection{Реализации динамических библиотек}

\subsubsection{bubble\_sort.cpp}

\lstinputlisting[language=C++,caption=bubble\_sort.cpp,basicstyle=\small\ttfamily]{inc/bubble_sort.cpp}

\subsubsection{quicksort.cpp}

\lstinputlisting[language=C++,caption=quicksort.cpp,basicstyle=\small\ttfamily]{inc/quicksort.cpp}

\subsection{Тестовые программы}

\subsubsection{program1.cpp}

\lstinputlisting[language=C++,caption=program1.cpp,basicstyle=\small\ttfamily]{inc/program1.cpp}

\subsubsection{program2.cpp}

\lstinputlisting[language=C++,caption=program2.cpp,basicstyle=\small\ttfamily]{inc/program2.cpp}

\subsection{Тестовый запуск программы}

\subsubsection{Program 1 (Статическая линковка)}

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab4\build> .\program1.exe
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
=== Program 1: Static Linking ===
Using: Bubble Sort (statically linked)
Commands:
  1 <num1> <num2> ... <numN>  - Sort array
  exit  - Exit program

> 1 5 2 8 1 3
23-56-59MSG program1 Input array:
5 2 8 1 3
23-56-59MSG program1 Sorted array:
1 2 3 5 8
> exit
23-56-59MSG program1 Exiting...
\end{verbatim}

Программа успешно использует статически слинкованную функцию сортировки. Код сортировки включен в исполняемый файл на этапе компиляции.

\subsubsection{Program 2 (Динамическая загрузка)}

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab4\build> .\program2.exe
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
=== Program 2: Dynamic Loading ===
Commands:
  0  - Switch between bubble_sort.dll and quicksort.dll
  1 <num1> <num2> ... <numN>  - Sort array
  exit  - Exit program

23-56-59MSG program2 Library loaded: bubble_sort.dll
> 0
23-56-59MSG program2 Library unloaded
23-56-59MSG program2 Library loaded: quicksort.dll
23-56-59MSG program2 Switched to: QuickSort (Hoare)
> 1 5 2 8 1 3
23-56-59MSG program2 Input array:
5 2 8 1 3
23-56-59MSG program2 Sorted array:
1 2 3 5 8
> exit
23-56-59MSG program2 Exiting...
\end{verbatim}

Программа успешно загружает DLL во время выполнения, переключается между реализациями и использует функции через указатели.

\subsection{Трассировка системных вызовов (WinDbg)}

Для демонстрации использования системных вызовов Windows API программа была запущена под отладчиком WinDbg с установленными breakpoints на ключевые функции уровня NTDLL (Native API).

\subsubsection{Команды WinDbg}

\begin{verbatim}
cd lab4
windbg .\build\program2.exe

# Загрузка символов
.reload
ld ntdll

# DLL Loading (Native API - NTDLL)
bp ntdll!LdrLoadDll ".echo === [LOAD] LdrLoadDll (LoadLibraryA) ===; g"
bp ntdll!LdrGetProcedureAddress ".echo === [PROC] LdrGetProcedureAddress (GetProcAddress) ===; g"
bp ntdll!LdrUnloadDll ".echo === [FREE] LdrUnloadDll (FreeLibrary) ===; g"

# Memory mapping для DLL
bp ntdll!NtOpenSection ".echo === [OPEN] NtOpenSection (DLL) ===; g"
bp ntdll!NtMapViewOfSection ".echo === [MAP] NtMapViewOfSection (DLL) ===; g"
bp ntdll!NtUnmapViewOfSection ".echo === [UNMAP] NtUnmapViewOfSection (DLL) ===; g"

# I/O
bp ntdll!NtReadFile ".echo === [READ] NtReadFile (console input) ===; g"
bp ntdll!NtWriteFile ".echo === [WRITE] NtWriteFile (console output) ===; g"

# Cleanup
bp ntdll!NtClose ".echo === [CLOSE] NtClose ===; g"

.logopen trace_lab4_full.log
g
\end{verbatim}

\subsubsection{Результаты трассировки}

Ниже представлен фрагмент лога с ключевыми системными вызовами (повторяющиеся строки сокращены):

\begin{verbatim}
... (initialization - загрузка системных DLL: advapi32.dll, msvcrt.dll, 
     sechost.dll, RPCRT4.dll и др.) ...

=== [WRITE] NtWriteFile (console output) ===
... (вывод приветственного сообщения) ...

# Initial DLL load (bubble_sort.dll)
=== [LOAD] LdrLoadDll (LoadLibraryA) ===
=== [OPEN] NtOpenSection (DLL) ===
=== [MAP] NtMapViewOfSection (DLL) ===
ModLoad: 00007ffe`aa090000 00007ffe`aa0b1000   
        D:\programming_projects\mai_os\lab4\build\bubble_sort.dll
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Library loaded: bubble_sort.dll") ...

# User input: "0" (switch DLL)
=== [READ] NtReadFile (console input) ===
=== [FREE] LdrUnloadDll (FreeLibrary) ===
=== [UNMAP] NtUnmapViewOfSection (DLL) ===
=== [CLOSE] NtClose ===
=== [LOAD] LdrLoadDll (LoadLibraryA) ===
=== [OPEN] NtOpenSection (DLL) ===
=== [MAP] NtMapViewOfSection (DLL) ===
ModLoad: 00007ffe`aa6b0000 00007ffe`aa6d1000   
        D:\programming_projects\mai_os\lab4\build\quicksort.dll
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Switched to: QuickSort (Hoare)") ...

# User input: "1 5 2 8 1 3" (sort array)
=== [READ] NtReadFile (console input) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Input array: 5 2 8 1 3") ...
... (sorting happens in DLL code - без системных вызовов) ...
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Sorted array: 1 2 3 5 8") ...

# User input: "exit"
=== [READ] NtReadFile (console input) ===
=== [FREE] LdrUnloadDll (FreeLibrary) ===
=== [UNMAP] NtUnmapViewOfSection (DLL) ===
=== [CLOSE] NtClose ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Exiting...") ...
\end{verbatim}

\subsubsection{Анализ трассировки}

Трассировка подтверждает следующую последовательность системных вызовов:

\textbf{Фаза 1: Инициализация процесса}
\begin{enumerate}
    \item Загрузка системных DLL (advapi32.dll, msvcrt.dll, sechost.dll, RPCRT4.dll и др.) через \texttt{LdrLoadDll}
    \item Множественные вызовы \texttt{NtOpenSection} и \texttt{NtMapViewOfSection} для маппинга системных библиотек
    \item Вывод приветственного сообщения через \texttt{NtWriteFile}
\end{enumerate}

\textbf{Фаза 2: Загрузка пользовательской DLL (bubble\_sort.dll)}
\begin{enumerate}
    \item \textbf{LdrLoadDll} — загрузка DLL в память процесса (вызывается из \texttt{LoadLibraryA()})
    \item \textbf{NtOpenSection} — открытие секции DLL в системной памяти
    \item \textbf{NtMapViewOfSection} — отображение DLL в адресное пространство процесса (видно ModLoad сообщение)
    \item \textbf{LdrGetProcedureAddress} — получение адреса функции \texttt{Sort} (вызывается из \texttt{GetProcAddress()})
    \item Множественные \texttt{NtClose} — закрытие дескрипторов, созданных при загрузке
\end{enumerate}

\textbf{Фаза 3: Переключение DLL (команда "0")}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды из консоли
    \item \textbf{LdrUnloadDll} — выгрузка текущей DLL (вызывается из \texttt{FreeLibrary()})
    \item \textbf{NtUnmapViewOfSection} — отмена отображения DLL из памяти
    \item \textbf{NtClose} — закрытие дескрипторов
    \item Повторение фазы 2 для загрузки \texttt{quicksort.dll}
\end{enumerate}

\textbf{Фаза 4: Выполнение сортировки (команда "1")}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды и аргументов из консоли
    \item \textbf{NtWriteFile} — вывод входного массива
    \item \textbf{Выполнение сортировки} — происходит в коде DLL без дополнительных системных вызовов (обычный код в адресном пространстве процесса)
    \item \textbf{NtWriteFile} — вывод отсортированного массива
\end{enumerate}

\textbf{Фаза 5: Завершение (команда "exit")}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды выхода
    \item \textbf{LdrUnloadDll} — выгрузка DLL
    \item \textbf{NtUnmapViewOfSection} — отмена отображения DLL
    \item \textbf{NtClose} — закрытие всех дескрипторов
    \item \textbf{NtWriteFile} — вывод сообщения о завершении
\end{enumerate}

\subsubsection{Ключевые наблюдения}

\begin{enumerate}
    \item \textbf{Загрузка DLL:} Процесс загрузки DLL включает несколько системных вызовов:
    \begin{itemize}
        \item \texttt{LdrLoadDll} — основная функция загрузки
        \item \texttt{NtOpenSection} — открытие секции DLL
        \item \texttt{NtMapViewOfSection} — маппинг DLL в память
        \item \texttt{LdrGetProcedureAddress} — получение адреса функции
    \end{itemize}
    Это больше системных вызовов, чем при статической линковке (где все разрешается на этапе компиляции).
    
    \item \textbf{Выполнение кода DLL:} После загрузки DLL код выполняется напрямую в адресном пространстве процесса. Сортировка массива не требует дополнительных системных вызовов — это обычный пользовательский код.
    
    \item \textbf{Переключение DLL:} При переключении между библиотеками происходит полная выгрузка одной DLL и загрузка другой. Это включает:
    \begin{itemize}
        \item Вызов \texttt{LdrUnloadDll} для выгрузки
        \item Вызов \texttt{NtUnmapViewOfSection} для отмены маппинга
        \item Повторение процесса загрузки для новой DLL
    \end{itemize}
    
    \item \textbf{Инициализация процесса:} В начале работы программы загружается множество системных DLL (advapi32.dll, msvcrt.dll и др.). Это нормальное поведение Windows при запуске любого процесса.
    
    \item \textbf{Сравнение со статической линковкой:} При статической линковке (Program 1) все эти системные вызовы отсутствуют — код сортировки уже включен в .exe файл. Это видно по отсутствию вызовов \texttt{LdrLoadDll} и \texttt{LdrGetProcedureAddress} в Program 1.
\end{enumerate}

\subsection{Системные вызовы Windows API}

\subsubsection{LoadLibraryA() / LdrLoadDll()}

Загружает DLL в адресное пространство процесса.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
HMODULE LoadLibraryA(LPCSTR lpLibFileName);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrLoadDll(
    PWSTR DllPath,
    PULONG DllCharacteristics,
    PUNICODE_STRING DllName,
    PVOID *BaseAddress
);
\end{lstlisting}

\textbf{Процесс загрузки:}
\begin{enumerate}
    \item Поиск DLL в системных путях и текущей директории
    \item Открытие секции DLL через \texttt{NtOpenSection}
    \item Маппинг DLL в память через \texttt{NtMapViewOfSection}
    \item Выполнение инициализации DLL (DllMain, если есть)
    \item Возврат handle модуля
\end{enumerate}

\subsubsection{GetProcAddress() / LdrGetProcedureAddress()}

Получает адрес экспортируемой функции из загруженной DLL.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
FARPROC GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrGetProcedureAddress(
    HMODULE ModuleHandle,
    PANSI_STRING FunctionName,
    WORD Ordinal,
    PVOID *FunctionAddress
);
\end{lstlisting}

\textbf{Процесс поиска:}
\begin{enumerate}
    \item Поиск функции в таблице экспорта DLL
    \item Проверка имени функции или порядкового номера
    \item Возврат адреса функции в памяти
\end{enumerate}

\subsubsection{FreeLibrary() / LdrUnloadDll()}

Выгружает DLL из памяти процесса.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
BOOL FreeLibrary(HMODULE hLibModule);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrUnloadDll(HMODULE ModuleHandle);
\end{lstlisting}

\textbf{Процесс выгрузки:}
\begin{enumerate}
    \item Выполнение финализации DLL (DllMain с флагом DLL\_PROCESS\_DETACH, если есть)
    \item Отмена маппинга через \texttt{NtUnmapViewOfSection}
    \item Закрытие дескрипторов через \texttt{NtClose}
    \item Освобождение памяти
\end{enumerate}

\subsubsection{NtMapViewOfSection()}

Отображает секцию (включая DLL) в адресное пространство процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{SectionHandle} — handle секции (DLL)
    \item \texttt{ProcessHandle} — handle процесса (текущий процесс)
    \item \texttt{BaseAddress} — базовый адрес для маппинга
    \item \texttt{ViewSize} — размер отображаемой области
    \item \texttt{Protect} — права доступа (PAGE\_EXECUTE\_READ для DLL)
\end{itemize}

\subsubsection{NtUnmapViewOfSection()}

Отменяет отображение секции из адресного пространства процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{ProcessHandle} — handle процесса
    \item \texttt{BaseAddress} — базовый адрес отображенной секции
\end{itemize}
