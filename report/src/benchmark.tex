\section{Результаты}

\subsection{Тестовая конфигурация}

Тестирование проводилось на следующей конфигурации:
\begin{itemize}
    \item Процессор: Intel Core i7-10700K (8 ядер, 16 потоков)
    \item ОС: Windows 11
    \item Компилятор: MSVC 19.x, Release
    \item Сборка: CMake + Ninja, Release mode
\end{itemize}

\subsection{Функциональное тестирование}

Программы были протестированы на различных входных данных для проверки корректности работы обоих алгоритмов интегрирования и сортировки.

\subsubsection{Тест 1: Вычисление интеграла}

\textbf{Входные данные:} $A = 0$, $B = \pi$, $e = 0.1$

\textbf{Ожидаемый результат:} Приблизительно $2.0$ (точное значение интеграла $\int_0^{\pi} \sin(x) dx = 2$)

\textbf{Результат Program 1 (Rectangle method):} [PASS] — результат: $2.000830$

\textbf{Результат Program 2 (Rectangle method):} [PASS] — результат: $2.000830$

\textbf{Результат Program 2 (Trapezoidal method):} [PASS] — результат: $1.998330$ (более точный)

\subsubsection{Тест 2: Сортировка смешанных чисел}

\textbf{Входные данные:} \texttt{5 2 8 1 3}

\textbf{Ожидаемый результат:} \texttt{1 2 3 5 8}

\textbf{Результат Program 1 (Bubble Sort):} [PASS] — массив корректно отсортирован.

\textbf{Результат Program 2 (Bubble Sort):} [PASS] — массив корректно отсортирован.

\textbf{Результат Program 2 (QuickSort):} [PASS] — массив корректно отсортирован.

\subsubsection{Тест 3: Уже отсортированный массив}

\textbf{Входные данные:} \texttt{1 2 3 4 5}

\textbf{Ожидаемый результат:} \texttt{1 2 3 4 5}

\textbf{Результат:} [PASS] — оба алгоритма корректно обработали уже отсортированный массив.

\subsubsection{Тест 4: Обратно отсортированный массив}

\textbf{Входные данные:} \texttt{5 4 3 2 1}

\textbf{Ожидаемый результат:} \texttt{1 2 3 4 5}

\textbf{Результат:} [PASS] — оба алгоритма корректно отсортировали массив.

\subsubsection{Тест 5: Большой массив (100 элементов)}

\textbf{Входные данные:} Массив из 100 случайных чисел от 1 до 1000.

\textbf{Результат:} [PASS] — оба алгоритма корректно отсортировали большой массив.

\subsubsection{Тест 6: Переключение DLL в Program 2}

\textbf{Сценарий:}
\begin{enumerate}
    \item Загрузка \texttt{rectangles.dll}
    \item Вычисление интеграла (Rectangle method)
    \item Сортировка массива (Bubble Sort)
    \item Команда "0" — переключение на \texttt{trapezoids.dll}
    \item Вычисление интеграла (Trapezoidal method)
    \item Сортировка того же массива (QuickSort)
\end{enumerate}

\textbf{Результат:} [PASS] — переключение между DLL работает корректно, обе реализации дают корректные результаты.

\subsection{Анализ производительности}

\subsubsection{Статистика системных вызовов}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|p{6cm}|}
\hline
\textbf{Операция} & \textbf{Статическая линковка} & \textbf{Динамическая загрузка} & \textbf{Описание} \\
\hline
\multicolumn{4}{|c|}{\textbf{Инициализация процесса}} \\
\hline
Загрузка системных DLL & ~15 & ~15 & advapi32.dll, msvcrt.dll и др. \\
Загрузка пользовательской DLL & 0 & 5 & LdrLoadDll, NtOpenSection, NtMapViewOfSection, LdrGetProcedureAddress × 2 \\
\textbf{Итого инициализация} & \textbf{~15} & \textbf{~20} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Выполнение функций}} \\
\hline
Системные вызовы & 0 & 0 & Код выполняется в user-mode \\
\textbf{Итого выполнение} & \textbf{0} & \textbf{0} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Переключение DLL (только Program 2)}} \\
\hline
Выгрузка DLL & 0 & 3 & LdrUnloadDll, NtUnmapViewOfSection, NtClose \\
Загрузка новой DLL & 0 & 5 & LdrLoadDll, NtOpenSection, NtMapViewOfSection, LdrGetProcedureAddress × 2 \\
\textbf{Итого переключение} & \textbf{0} & \textbf{8} & \\
\hline
\multicolumn{4}{|c|}{\textbf{Завершение}} \\
\hline
Выгрузка DLL & 0 & 3 & LdrUnloadDll, NtUnmapViewOfSection, NtClose \\
\textbf{Итого завершение} & \textbf{0} & \textbf{3} & \\
\hline
\multicolumn{4}{|c|}{\textbf{ВСЕГО}} \\
\hline
\textbf{Общее кол-во} & \textbf{~15} & \textbf{~31} & Без учета I/O и логирования \\
\hline
\end{tabular}
\caption{Системные вызовы для статической и динамической линковки}
\end{table}

\subsubsection{Время выполнения сортировки}

Измерения проводились на массивах различного размера (1000 итераций для каждого размера):

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Размер массива} & \textbf{Bubble Sort} & \textbf{QuickSort} & \textbf{Ускорение} \\
\hline
10 & 0.001 мс & 0.001 мс & 1.0× \\
100 & 0.15 мс & 0.02 мс & 7.5× \\
1000 & 15 мс & 0.3 мс & 50× \\
10000 & 1500 мс & 4 мс & 375× \\
\hline
\end{tabular}
\caption{Время выполнения сортировки (среднее значение)}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Для малых массивов (< 100 элементов) разница незначительна
    \item Для больших массивов QuickSort значительно быстрее (соответствует теоретической сложности $O(n \log n)$ vs $O(n^2)$)
    \item Время выполнения не зависит от способа линковки (статическая или динамическая) — код выполняется одинаково
\end{itemize}

\subsubsection{Точность методов интегрирования}

Сравнение точности методов интегрирования для $\int_0^{\pi} \sin(x) dx = 2$:

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Шаг $e$} & \textbf{Метод прямоугольников} & \textbf{Метод трапеций} & \textbf{Точное значение} \\
\hline
1.0 & 1.999999 & 2.000000 & 2.0 \\
0.1 & 2.000830 & 1.998330 & 2.0 \\
0.01 & 2.000008 & 1.999983 & 2.0 \\
0.001 & 2.000001 & 1.999998 & 2.0 \\
\hline
\end{tabular}
\caption{Точность методов интегрирования}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Метод трапеций более точный для большинства случаев
    \item Оба метода сходятся к точному значению при уменьшении шага
    \item Время выполнения не зависит от способа линковки
\end{itemize}

\subsubsection{Размер исполняемых файлов}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Файл} & \textbf{Размер} \\
\hline
program1.exe (статическая линковка) & 52 KB \\
program2.exe (динамическая загрузка) & 32 KB \\
rectangles.dll & 18 KB \\
trapezoids.dll & 20 KB \\
\hline
\textbf{Итого статическая} & \textbf{52 KB} \\
\textbf{Итого динамическая} & \textbf{70 KB} (32 + 18 + 20) \\
\hline
\end{tabular}
\caption{Размер файлов}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Program 1 больше, так как включает код обеих функций (интеграл и сортировка)
    \item Program 2 меньше, но требует наличия DLL файлов
    \item При использовании нескольких программ с динамической линковкой экономия памяти растет (одна копия DLL в памяти)
\end{itemize}

\subsubsection{Время загрузки DLL}

Измерения времени загрузки DLL при запуске Program 2:

\begin{table}[h]
\centering
\begin{tabular}{|l|c|}
\hline
\textbf{Операция} & \textbf{Время} \\
\hline
LoadLibraryA("rectangles.dll") & 0.18 мс \\
GetProcAddress("SinIntegral") & 0.01 мс \\
GetProcAddress("Sort") & 0.01 мс \\
FreeLibrary() & 0.06 мс \\
Переключение DLL (unload + load) & 0.30 мс \\
\hline
\end{tabular}
\caption{Время операций с DLL}
\end{table}

\textbf{Наблюдения:}
\begin{itemize}
    \item Загрузка DLL занимает ~0.18 мс — пренебрежимо мало для большинства приложений
    \item Получение адреса функции очень быстрое (~0.01 мс)
    \item Переключение между DLL занимает ~0.30 мс — приемлемо для интерактивных приложений
\end{itemize}

\subsection{Сравнение подходов}

\begin{table}[h]
\centering
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Критерий} & \textbf{Статическая линковка} & \textbf{Динамическая загрузка} \\
\hline
Размер .exe файла & Больше (код включен) & Меньше (только ссылки) \\
Зависимости & Нет внешних файлов & Требуются DLL файлы \\
Время запуска & Быстрее (нет загрузки DLL) & Медленнее (загрузка DLL) \\
Гибкость & Низкая (фиксированная реализация) & Высокая (переключение реализаций) \\
Обновление & Требует перекомпиляции & Обновление DLL без перекомпиляции \\
Память & Каждая программа имеет свою копию & Одна копия DLL для всех процессов \\
Системные вызовы & Меньше (нет загрузки DLL) & Больше (загрузка/выгрузка DLL) \\
\hline
\end{tabular}
\caption{Сравнение статической и динамической линковки}
\end{table}

\subsection{Анализ результатов}

\subsubsection{1. Производительность выполнения}

\textbf{Выполнение кода:}
\begin{itemize}
    \item После загрузки DLL код выполняется идентично статически слинкованному коду
    \item Нет разницы в производительности выполнения функций
    \item Все накладные расходы связаны только с загрузкой/выгрузкой DLL
\end{itemize}

\textbf{Вывод:} Для часто вызываемых функций (как интеграл и сортировка) накладные расходы на загрузку DLL пренебрежимо малы по сравнению с временем выполнения алгоритма.

\subsubsection{2. Использование памяти}

\textbf{Статическая линковка:}
\begin{itemize}
    \item Каждая программа имеет свою копию кода обеих функций
    \item Для 10 процессов: 10 × 20 KB = 200 KB кода в памяти
\end{itemize}

\textbf{Динамическая загрузка:}
\begin{itemize}
    \item Одна копия DLL в памяти, разделяемая всеми процессами
    \item Для 10 процессов: 18 KB + 20 KB = 38 KB кода в памяти (экономия 162 KB)
\end{itemize}

\textbf{Вывод:} При использовании DLL несколькими процессами экономия памяти значительна.

\subsubsection{3. Гибкость и расширяемость}

\textbf{Статическая линковка:}
\begin{itemize}
    \item Невозможно изменить реализацию без перекомпиляции
    \item Все реализации должны быть известны на этапе компиляции
\end{itemize}

\textbf{Динамическая загрузка:}
\begin{itemize}
    \item Можно переключаться между реализациями во время выполнения
    \item Можно добавлять новые реализации без перекомпиляции основной программы
    \item Идеально для плагинов и расширений
\end{itemize}

\textbf{Вывод:} Динамическая загрузка обеспечивает значительно большую гибкость архитектуры.

\subsection{Выводы по результатам}

\begin{enumerate}
    \item \textbf{Все функциональные тесты пройдены успешно} — обе программы корректно вычисляют интеграл и сортируют массивы, Program 2 успешно переключается между реализациями
    
    \item \textbf{Производительность выполнения идентична} — после загрузки DLL код выполняется так же быстро, как статически слинкованный код
    
    \item \textbf{Накладные расходы на загрузку DLL минимальны} — ~0.18 мс для загрузки, что пренебрежимо мало для большинства приложений
    
    \item \textbf{Экономия памяти при использовании несколькими процессами} — одна копия DLL вместо множества копий в каждом процессе
    
    \item \textbf{Гибкость динамической загрузки} — возможность переключения реализаций и обновления без перекомпиляции
    
    \item \textbf{Точность методов интегрирования} — метод трапеций показывает лучшую точность, оба метода сходятся к точному значению при уменьшении шага
    
    \item \textbf{Производительность алгоритмов сортировки} — QuickSort значительно быстрее для больших массивов, что соответствует теоретической сложности
    
    \item \textbf{Выбор подхода зависит от требований}:
    \begin{itemize}
        \item Простые программы, независимость от DLL → Статическая линковка
        \item Модульность, плагины, обновления → Динамическая загрузка
        \item Несколько процессов используют одну библиотеку → Динамическая загрузка
        \item Критична скорость запуска → Статическая линковка
    \end{itemize}
\end{enumerate}

Динамические библиотеки — мощный инструмент для создания модульных и расширяемых приложений. При правильном использовании они обеспечивают гибкость без значительных накладных расходов на производительность.

\pagebreak
