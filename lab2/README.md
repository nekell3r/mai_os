# Лабораторная работа №2 - Многопоточная обработка данных

## Задание

Вариант 11: Наложить K раз медианный фильтр на матрицу, состоящую из целых чисел. Размер окна задается пользователем.

## Описание программы

Программа применяет медианный фильтр к матрице целых чисел в многопоточном режиме (Windows версия). Медианный фильтр - это нелинейный цифровой фильтр, который используется для уменьшения шума в изображениях и сигналах. Для каждого элемента матрицы фильтр вычисляет медиану значений в окрестности заданного размера и заменяет центральное значение на эту медиану.

### Особенности реализации

- **Многопоточность Windows**: Матрица разделяется на несколько частей по строкам, каждая часть обрабатывается в отдельном потоке (WinAPI)
- **Ограничение потоков**: Максимальное количество потоков задается параметром командной строки
- **Обработка границ**: При обработке краевых элементов используется стратегия "ближайшее значение"
- **Измерение производительности**: Программа измеряет и выводит время выполнения для каждой итерации
- **Логирование**: Использование системы логирования из common/comm.h

### Структура проекта

```
lab2/
├── CMakeLists.txt              # Конфигурация сборки
├── README.md                   # Этот файл
├── BUILD.md                    # Инструкции по сборке
├── test_matrix.txt             # Пример входных данных (10x10)
├── test_performance.ps1        # PowerShell скрипт для тестирования
├── common/                     # Общие файлы (как в lab1)
│   ├── comm.h                  # Общие инклюды и логирование
│   ├── defines.h               # Общие определения
│   ├── errors.h/hpp/cpp        # Обработка ошибок
│   └── CMakeLists.txt
└── src/
    ├── main.cpp                # Главная программа
    ├── median_filter.h         # Заголовочный файл фильтра
    ├── median_filter.cpp       # Реализация фильтра (Windows)
    └── CMakeLists.txt          # Конфигурация сборки модуля
```

## Использование

### Синтаксис

```bash
median_filter [опции]
```

### Опции командной строки

- `-f <файл>` - Входной файл с матрицей
- `-g <rows> <cols>` - Сгенерировать случайную матрицу размером rows x cols
- `-w <размер>` - Размер окна фильтра (должен быть нечетным, по умолчанию 3)
- `-k <число>` - Количество итераций применения фильтра (по умолчанию 1)
- `-t <число>` - Максимальное количество потоков (по умолчанию 1)
- `-o <файл>` - Выходной файл для сохранения результата
- `-p` - Вывести результат на экран (только для маленьких матриц ≤10x10)
- `-h` - Показать справку

### Формат входного файла

Первая строка: `<количество_строк> <количество_столбцов>`
Далее идет матрица построчно:

```
10 10
150 200 180 190 210 160 170 200 190 180
180 160 170 180 160 150 180 170 160 170
...
```

### Примеры использования

1. **Обработка файла с использованием 4 потоков:**
   ```bash
   median_filter -f test_matrix.txt -w 3 -k 1 -t 4 -o output.txt
   ```

2. **Генерация большой матрицы и обработка с разным количеством потоков:**
   ```bash
   # 1 поток
   median_filter -g 1000 1000 -w 5 -k 2 -t 1
   
   # 4 потока
   median_filter -g 1000 1000 -w 5 -k 2 -t 4
   
   # 8 потоков
   median_filter -g 1000 1000 -w 5 -k 2 -t 8
   ```

3. **Обработка с выводом результата на экран (для маленьких матриц):**
   ```bash
   median_filter -f test_matrix.txt -w 3 -k 1 -t 2 -p
   ```

## Мониторинг потоков

### Windows

**Task Manager:**
1. Открыть Task Manager (Ctrl+Shift+Esc)
2. Вкладка "Подробности" (Details)
3. Найти процесс `median_filter.exe`
4. Правой кнопкой -> "Столбцы" -> Добавить "Потоки"

**PowerShell:**
```powershell
# Получить PID процесса
Get-Process -Name median_filter

# Показать потоки
Get-Process -Name median_filter | Select-Object -ExpandProperty Threads

# Или в реальном времени
while ($true) { 
    Clear-Host; 
    Get-Process -Name median_filter | Select-Object Name, Id, Threads | Format-Table; 
    Start-Sleep -Seconds 1 
}
```

### Дополнительно: Process Explorer

Для более подробного мониторинга можно использовать [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer) от Microsoft Sysinternals.

## Сборка

См. инструкции в файле [BUILD.md](BUILD.md)

---

## Заметки для отчета

### Что нужно исследовать и включить в отчет:

#### 1. Зависимость ускорения от количества потоков

**Ускорение (Speedup):**
```
S(N) = T(1) / T(N)
```
где:
- `T(1)` - время выполнения на 1 потоке
- `T(N)` - время выполнения на N потоках

**Что замерять:**
- Фиксированная матрица (например, 1000x1000)
- Фиксированные параметры (окно 5x5, K=3)
- Варьировать количество потоков: 1, 2, 4, 6, 8, 12, 16
- Для каждого запустить 3-5 раз и взять среднее

**Ожидаемый результат:**
- График зависимости ускорения от количества потоков
- Сравнение с теоретическим линейным ускорением
- Объяснение отклонений (overhead на создание потоков, синхронизацию, кэш)

#### 2. Эффективность параллелизации

**Эффективность (Efficiency):**
```
E(N) = S(N) / N
```

**Анализ:**
- При каком количестве потоков эффективность начинает падать?
- Почему? (overhead, количество ядер, гиперпоточность)
- Оптимальное количество потоков для данной задачи

#### 3. Зависимость от размера матрицы

**Эксперименты:**
- Размеры: 100x100, 500x500, 1000x1000, 2000x2000, 4000x4000
- Фиксированное количество потоков (например, 4 или 8)
- Построить график T(размер)

**Объяснение:**
- Как размер данных влияет на эффективность параллелизации?
- При малых размерах overhead может превышать выигрыш
- При больших - лучшая утилизация потоков

#### 4. Зависимость от размера окна фильтра

**Эксперименты:**
- Размеры окна: 3x3, 5x5, 7x7, 9x9, 11x11
- Фиксированная матрица и количество потоков
- Замерить время

**Анализ:**
- Как растет вычислительная сложность? (квадратично от размера окна)
- Влияет ли это на эффективность распараллеливания?

#### 5. Зависимость от количества итераций (K)

**Эксперименты:**
- K = 1, 2, 3, 5, 10
- Разное количество потоков

**Вопросы:**
- Линейно ли растет время с ростом K?
- Одинаково ли ускорение для разных K?

#### 6. Накладные расходы (Overhead)

**Измерить:**
- Время создания потоков
- Время синхронизации между итерациями
- Memory overhead

**Объяснение:**
- При каких условиях overhead значителен?
- Как минимизировать?

#### 7. Влияние архитектуры процессора

**Информация для отчета:**
- Количество физических ядер
- Наличие Hyper-Threading (SMT)
- Размер кэшей (L1, L2, L3)
- Как это влияет на результаты?

#### 8. Закон Амдала

**Теоретический анализ:**
```
S(N) = 1 / ((1 - P) + P/N)
```
где P - доля параллелизуемого кода

**Сравнить:**
- Теоретическое ускорение по закону Амдала
- Реальное измеренное ускорение
- Объяснить расхождения

#### 9. Масштабируемость

**Strong scaling:**
- Фиксированный размер задачи, растет количество потоков
- Насколько хорошо ускоряется?

**Weak scaling:**
- Размер задачи растет пропорционально количеству потоков
- Остается ли время выполнения константным?

### Рекомендации по оформлению отчета:

1. **Графики обязательны:**
   - Ускорение vs количество потоков
   - Эффективность vs количество потоков
   - Время выполнения vs размер матрицы
   - Сравнение теории и практики

2. **Таблицы с данными:**
   - Сырые данные измерений
   - Вычисленные метрики (ускорение, эффективность)

3. **Скриншоты:**
   - Task Manager/top показывающий работающие потоки
   - Пример вывода программы

4. **Объяснения:**
   - Почему ускорение не линейное?
   - Влияние кэша процессора
   - False sharing (если есть)
   - Context switching
   - NUMA (если применимо)

5. **Выводы:**
   - Оптимальное количество потоков для данной задачи
   - Рекомендации по использованию
   - Какие параметры больше всего влияют на производительность

### Автоматическое тестирование производительности

В проекте есть готовый PowerShell скрипт для автоматического тестирования:

```powershell
# Скопируйте скрипт в директорию build/
copy test_performance.ps1 build\

# Запустите из директории build/
cd build
.\test_performance.ps1
```

Скрипт автоматически:
- Запускает тесты с разными размерами матриц (100x100, 500x500, 1000x1000)
- Варьирует количество потоков (1, 2, 4, 8)
- Повторяет каждый тест 3 раза для усреднения результатов
- Вычисляет ускорение (speedup) и эффективность
- Сохраняет результаты в `performance_results.csv`
- Выводит анализ и рекомендации по оптимальному количеству потоков

Вы можете отредактировать скрипт для других параметров тестирования.

### Дополнительные эксперименты (по желанию):

1. **Разные стратегии разделения работы:**
   - По строкам (текущая реализация)
   - По столбцам
   - По блокам
   - Сравнить производительность

2. **Оптимизации:**
   - Использование пула потоков вместо создания на каждую итерацию
   - Prefetching данных
   - SIMD инструкции

3. **Профилирование:**
   - Где программа тратит больше всего времени?
   - Cache misses
   - Branch mispredictions

