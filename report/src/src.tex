\section{Метод решения}

\subsection{Динамические библиотеки (DLL) в Windows}

Динамические библиотеки (Dynamic Link Libraries, DLL) — это модули кода, которые загружаются в память процесса во время выполнения программы. В отличие от статической линковки, где код библиотеки включается в исполняемый файл на этапе компиляции, DLL загружаются по требованию.

\textbf{Преимущества динамических библиотек:}
\begin{itemize}
    \item \textbf{Экономия памяти} — одна копия DLL может использоваться несколькими процессами
    \item \textbf{Модульность} — можно обновлять библиотеки без перекомпиляции основной программы
    \item \textbf{Гибкость} — выбор реализации во время выполнения
    \item \textbf{Разделение кода} — уменьшение размера исполняемых файлов
\end{itemize}

\textbf{Недостатки:}
\begin{itemize}
    \item Требуется наличие DLL файлов в системе
    \item Возможны проблемы с версиями (DLL Hell)
    \item Накладные расходы на загрузку во время выполнения
\end{itemize}

\subsection{Два способа использования библиотек}

\subsubsection{Статическая линковка (Program 1)}

При статической линковке код библиотеки включается в исполняемый файл на этапе компиляции. Линкер разрешает все ссылки на функции библиотеки, и они становятся частью .exe файла.

\textbf{Характеристики:}
\begin{itemize}
    \item Размер .exe файла больше (включает код библиотеки)
    \item Все зависимости разрешены на этапе компиляции
    \item Нет необходимости в отдельных DLL файлах
    \item Невозможно изменить реализацию без перекомпиляции
\end{itemize}

\subsubsection{Динамическая загрузка (Program 2)}

При динамической загрузке библиотека загружается в память во время выполнения программы с помощью системных вызовов Windows API.

\textbf{Характеристики:}
\begin{itemize}
    \item Размер .exe файла меньше
    \item Библиотека загружается по требованию
    \item Можно переключаться между разными реализациями во время выполнения
    \item Требуется наличие DLL файлов в системе
\end{itemize}

\subsection{Системные вызовы Windows API для работы с DLL}

\subsubsection{LoadLibraryA()}

Загружает DLL в адресное пространство процесса.

\begin{lstlisting}[language=C++]
HMODULE LoadLibraryA(LPCSTR lpLibFileName);
\end{lstlisting}

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{lpLibFileName} — путь к DLL файлу (например, "rectangles.dll")
\end{itemize}

\textbf{Возвращает:} Handle модуля (HMODULE) или NULL при ошибке.

\textbf{Низкоуровневый вызов:} \texttt{LdrLoadDll()} в ntdll.dll

\subsubsection{GetProcAddress()}

Получает адрес экспортируемой функции из загруженной DLL.

\begin{lstlisting}[language=C++]
FARPROC GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
);
\end{lstlisting}

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{hModule} — handle модуля, полученный из \texttt{LoadLibraryA()}
    \item \texttt{lpProcName} — имя функции (например, "SinIntegral" или "Sort")
\end{itemize}

\textbf{Возвращает:} Указатель на функцию или NULL при ошибке.

\textbf{Низкоуровневый вызов:} \texttt{LdrGetProcedureAddress()} в ntdll.dll

\subsubsection{FreeLibrary()}

Выгружает DLL из памяти процесса.

\begin{lstlisting}[language=C++]
BOOL FreeLibrary(HMODULE hLibModule);
\end{lstlisting}

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{hLibModule} — handle модуля для выгрузки
\end{itemize}

\textbf{Возвращает:} TRUE при успехе, FALSE при ошибке.

\textbf{Низкоуровневый вызов:} \texttt{LdrUnloadDll()} в ntdll.dll

\subsection{Контракты функций}

\subsubsection{Контракт функции интеграла}

Все реализации должны соответствовать единому контракту:

\begin{lstlisting}[language=C++]
extern "C" {
    float SinIntegral(float A, float B, float e);
}
\end{lstlisting}

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{A} — нижний предел интегрирования
    \item \texttt{B} — верхний предел интегрирования
    \item \texttt{e} — шаг интегрирования
\end{itemize}

\textbf{Возвращает:} Значение интеграла функции $\sin(x)$ на отрезке $[A, B]$.

\subsubsection{Контракт функции сортировки}

Все реализации должны соответствовать единому контракту:

\begin{lstlisting}[language=C++]
extern "C" {
    int* Sort(int* array, int size);
}
\end{lstlisting}

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{array} — указатель на массив целых чисел
    \item \texttt{size} — размер массива
\end{itemize}

\textbf{Возвращает:} Указатель на отсортированный массив (тот же массив, сортировка in-place).

\textbf{Важно:} Использование \texttt{extern "C"} необходимо для предотвращения name mangling в C++, что позволяет корректно находить функцию через \texttt{GetProcAddress()}.

\subsection{Алгоритмы численного интегрирования}

\subsubsection{Метод прямоугольников}

Метод численного интегрирования, основанный на аппроксимации функции постоянным значением на каждом интервале.

\textbf{Алгоритм:}
\begin{enumerate}
    \item Разбиение отрезка $[A, B]$ на интервалы шириной $e$
    \item Для каждого интервала вычисление значения функции в середине интервала
    \item Суммирование площадей прямоугольников: $S = \sum e \cdot f(x_{mid})$
\end{enumerate}

\textbf{Особенности:}
\begin{itemize}
    \item Простая реализация
    \item Точность зависит от шага $e$
    \item Использует среднее значение функции на интервале
\end{itemize}

\subsubsection{Метод трапеций}

Метод численного интегрирования, основанный на аппроксимации функции линейной функцией на каждом интервале.

\textbf{Алгоритм:}
\begin{enumerate}
    \item Разбиение отрезка $[A, B]$ на интервалы шириной $e$
    \item Для каждого интервала вычисление значений функции на границах
    \item Суммирование площадей трапеций: $S = \sum e \cdot \frac{f(x_i) + f(x_{i+1})}{2}$
\end{enumerate}

\textbf{Особенности:}
\begin{itemize}
    \item Более точный, чем метод прямоугольников
    \item Использует среднее значение функции на границах интервала
    \item Точность также зависит от шага $e$
\end{itemize}

\subsection{Алгоритмы сортировки}

\subsubsection{Пузырьковая сортировка (Bubble Sort)}

Классический алгоритм сортировки с временной сложностью $O(n^2)$.

\textbf{Алгоритм:}
\begin{enumerate}
    \item Проход по массиву от начала до конца
    \item Сравнение соседних элементов
    \item Если элементы в неправильном порядке — обмен
    \item Повторение для всех элементов
\end{enumerate}

\textbf{Особенности:}
\begin{itemize}
    \item Простая реализация
    \item Стабильная сортировка
    \item Медленная для больших массивов
\end{itemize}

\subsubsection{Сортировка Хоара (QuickSort)}

Эффективный алгоритм сортировки с временной сложностью $O(n \log n)$ в среднем случае.

\textbf{Алгоритм:}
\begin{enumerate}
    \item Выбор опорного элемента (pivot)
    \item Разделение массива на две части: элементы меньше pivot и элементы больше pivot
    \item Рекурсивная сортировка обеих частей
\end{enumerate}

\textbf{Особенности:}
\begin{itemize}
    \item Быстрая сортировка для больших массивов
    \item Нестабильная сортировка
    \item Использует схему разбиения Хоара (Hoare partition scheme)
\end{itemize}

\section{Описание программы}

\subsection{Структура программы}

Программа состоит из следующих компонентов:

\begin{itemize}
    \item \textbf{Динамические библиотеки:}
    \begin{itemize}
        \item \texttt{rectangles.dll} — содержит обе функции: \texttt{SinIntegral} (метод прямоугольников) и \texttt{Sort} (пузырьковая сортировка)
        \item \texttt{trapezoids.dll} — содержит обе функции: \texttt{SinIntegral} (метод трапеций) и \texttt{Sort} (QuickSort)
    \end{itemize}
    
    \item \textbf{Интерфейсы:}
    \begin{itemize}
        \item \texttt{integral\_interface.h} — определение контракта функции \texttt{SinIntegral()}
        \item \texttt{sort\_interface.h} — определение контракта функции \texttt{Sort()}
    \end{itemize}
    
    \item \textbf{Тестовые программы:}
    \begin{itemize}
        \item \texttt{program1.exe} — статическая линковка (использует rectangles, обе функции)
        \item \texttt{program2.exe} — динамическая загрузка (переключение между rectangles.dll и trapezoids.dll)
    \end{itemize}
    
    \item \textbf{Общие модули:}
    \begin{itemize}
        \item \texttt{common/comm.h} — система логирования с временными метками
        \item \texttt{common/defines.h} — общие определения
        \item \texttt{common/errors.h/cpp} — обработка ошибок
    \end{itemize}
\end{itemize}

\subsection{Program 1: Статическая линковка}

Программа использует библиотеку \texttt{rectangles}, которая статически слинкована на этапе компиляции. Библиотека содержит обе функции: \texttt{SinIntegral} (метод прямоугольников) и \texttt{Sort} (пузырьковая сортировка).

\textbf{Особенности:}
\begin{itemize}
    \item Код обеих функций включен в .exe файл
    \item Нет необходимости в DLL файлах
    \item Невозможно изменить алгоритм без перекомпиляции
    \item Больший размер исполняемого файла
\end{itemize}

\textbf{Алгоритм работы:}
\begin{enumerate}
    \item Вывод приветственного сообщения
    \item Цикл обработки команд:
    \begin{enumerate}
        \item Чтение команды из консоли
        \item Если команда "1" — парсинг параметров $A$, $B$, $e$ и вызов \texttt{SinIntegral()}
        \item Если команда "2" — парсинг чисел и вызов \texttt{Sort()}
        \item Вывод результата
        \item Если команда "exit" — завершение программы
    \end{enumerate}
\end{enumerate}

\subsection{Program 2: Динамическая загрузка}

Программа загружает DLL во время выполнения и может переключаться между разными реализациями. Каждая библиотека содержит обе функции.

\textbf{Особенности:}
\begin{itemize}
    \item Класс \texttt{DynamicLibrary} для управления загрузкой DLL
    \item Переключение между \texttt{rectangles.dll} и \texttt{trapezoids.dll} командой "0"
    \item При загрузке библиотеки получаются адреса обеих функций (\texttt{SinIntegral} и \texttt{Sort})
    \item Меньший размер .exe файла
    \item Требуется наличие DLL файлов в той же директории
\end{itemize}

\textbf{Алгоритм работы:}
\begin{enumerate}
    \item Вывод приветственного сообщения
    \item Загрузка начальной библиотеки (\texttt{rectangles.dll})
    \begin{itemize}
        \item Вызов \texttt{LoadLibraryA("rectangles.dll")}
        \item Получение адреса \texttt{SinIntegral} через \texttt{GetProcAddress()}
        \item Получение адреса \texttt{Sort} через \texttt{GetProcAddress()}
    \end{itemize}
    \item Цикл обработки команд:
    \begin{enumerate}
        \item Чтение команды из консоли
        \item Если команда "0" — переключение между DLL:
        \begin{itemize}
            \item Выгрузка текущей DLL (\texttt{FreeLibrary()})
            \item Загрузка другой DLL (\texttt{LoadLibraryA()})
            \item Получение адресов обеих функций (\texttt{GetProcAddress()})
        \end{itemize}
        \item Если команда "1" — парсинг параметров и вызов \texttt{SinIntegral()} через указатель
        \item Если команда "2" — парсинг чисел и вызов \texttt{Sort()} через указатель
        \item Вывод результата
        \item Если команда "exit" — выгрузка DLL и завершение
    \end{enumerate}
\end{enumerate}

\subsection{Класс DynamicLibrary}

Класс инкапсулирует работу с динамическими библиотеками:

\begin{lstlisting}[language=C++]
class DynamicLibrary {
private:
    HMODULE hModule;           // Handle загруженной DLL
    IntegralFunc integralFunc; // Указатель на функцию SinIntegral
    SortFunc sortFunc;          // Указатель на функцию Sort
    std::string currentLib;    // Имя текущей библиотеки
    
public:
    bool load(const std::string& dllPath);  // Загрузка DLL
    void unload();                          // Выгрузка DLL
    bool isLoaded() const;                 // Проверка загрузки
    IntegralFunc getIntegralFunc() const;   // Получение указателя на SinIntegral
    SortFunc getSortFunc() const;           // Получение указателя на Sort
};
\end{lstlisting}

\textbf{Метод load():}
\begin{enumerate}
    \item Вызов \texttt{unload()} для освобождения предыдущей библиотеки
    \item Загрузка DLL через \texttt{LoadLibraryA()}
    \item Проверка успешности загрузки
    \item Получение адреса функции \texttt{SinIntegral} через \texttt{GetProcAddress()}
    \item Получение адреса функции \texttt{Sort} через \texttt{GetProcAddress()}
    \item Сохранение handle и указателей на функции
\end{enumerate}

\textbf{Метод unload():}
\begin{enumerate}
    \item Проверка наличия загруженной библиотеки
    \item Вызов \texttt{FreeLibrary()}
    \item Сброс handle и указателей на функции
\end{enumerate}

\subsection{Обработка ошибок}

Все критические операции проверяются:

\begin{itemize}
    \item \textbf{LoadLibraryA()} — проверка возвращаемого значения, при ошибке вывод кода через \texttt{GetLastError()}
    \item \textbf{GetProcAddress()} — проверка указателей на обе функции
    \item \textbf{Валидация входных данных} — проверка параметров интеграла ($A < B$, $e > 0$) и размера массива (максимум 1000 элементов)
    \item \textbf{Логирование} — все операции логируются через \texttt{LogMsg()} и \texttt{LogErr()}
\end{itemize}

\subsection{Сборка проекта}

Проект собирается с помощью CMake:

\begin{verbatim}
mkdir build
cd build
cmake -G Ninja -DCMAKE_BUILD_TYPE=Release ..
ninja
\end{verbatim}

\textbf{Результаты сборки:}
\begin{itemize}
    \item \texttt{rectangles.dll} и \texttt{trapezoids.dll} в \texttt{build/}
    \item \texttt{program1.exe} и \texttt{program2.exe} в \texttt{build/}
    \item DLL файлы автоматически копируются в директорию \texttt{program2.exe} для динамической загрузки
\end{itemize}

\subsection{Использование программ}

\textbf{Program 1 (Статическая линковка):}
\begin{verbatim}
> 1 0 3.14159 0.1
Integral of sin(x) on [0, 3.14159] with step 0.1 (Rectangle method):
Result: 2.000830
> 2 5 2 8 1 3
Input array (Bubble Sort):
5 2 8 1 3
Sorted array:
1 2 3 5 8
> exit
\end{verbatim}

\textbf{Program 2 (Динамическая загрузка):}
\begin{verbatim}
> 1 0 3.14159 0.1
Integral of sin(x) on [0, 3.14159] with step 0.1 (Rectangle method):
Result: 2.000830
> 2 5 2 8 1 3
Input array (Bubble Sort):
5 2 8 1 3
Sorted array:
1 2 3 5 8
> 0
Switched to: Trapezoidal method / QuickSort
> 1 0 3.14159 0.1
Integral of sin(x) on [0, 3.14159] with step 0.1 (Trapezoidal method):
Result: 1.998330
> 2 5 2 8 1 3
Input array (QuickSort (Hoare)):
5 2 8 1 3
Sorted array:
1 2 3 5 8
> exit
\end{verbatim}
