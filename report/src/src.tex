\section{Метод решения}

\subsection{Медианный фильтр}

Медианный фильтр — это нелинейный цифровой фильтр, часто используемый для удаления шума из изображений и сигналов. Основная идея заключается в замене каждого элемента матрицы медианой значений в окрестности заданного размера.

Для каждого элемента матрицы с координатами $(i, j)$:
\begin{enumerate}
    \item Выбирается окно размером $w \times w$ с центром в точке $(i, j)$
    \item Все значения в окне сортируются
    \item Центральное значение (медиана) заменяет исходное значение элемента $(i, j)$
\end{enumerate}

Медианный фильтр эффективен для удаления импульсного шума (<<salt-and-pepper noise>>) при сохранении резких границ, в отличие от линейных фильтров, которые могут размывать изображение.

\subsection{Обработка границ матрицы}

При обработке элементов на границах матрицы окно фильтра выходит за пределы матрицы. Для решения этой проблемы используется стратегия <<ближайшее значение>> (clamp to edge): координаты, выходящие за границы, заменяются на ближайшие допустимые координаты.

\subsection{Распараллеливание алгоритма}

Вычисление медианы для каждого элемента матрицы является независимой операцией, что делает задачу идеально подходящей для распараллеливания. Используется следующий подход:

\begin{enumerate}
    \item Матрица разделяется на $N$ частей по строкам, где $N$ — количество потоков
    \item Каждому потоку назначается диапазон строк для обработки
    \item Потоки работают независимо, обрабатывая свои строки
    \item После завершения всех потоков результат готов
\end{enumerate}

Данный подход называется <<разделением данных>> (data partitioning) и не требует синхронизации между потоками, так как каждый поток пишет в уникальные ячейки выходной матрицы.

\textbf{Пример разделения для 4 потоков и матрицы 100 строк:}
\begin{itemize}
    \item Поток 0: строки 0--24 (25 строк)
    \item Поток 1: строки 25--49 (25 строк)
    \item Поток 2: строки 50--74 (25 строк)
    \item Поток 3: строки 75--99 (25 строк)
\end{itemize}

\subsection{Теоретическое ускорение}

Согласно закону Амдала, теоретическое ускорение при распараллеливании задачи на $N$ потоков определяется формулой:
\[
S(N) = \frac{1}{(1-P) + \frac{P}{N}}
\]
где $P$ — доля параллелизуемого кода (в нашем случае близка к 1).

В идеальном случае (без накладных расходов) ускорение должно быть линейным: $S(N) \approx N$.

Однако реальное ускорение меньше из-за:
\begin{itemize}
    \item Накладных расходов на создание и управление потоками
    \item Конкуренции за кэш процессора
    \item Переключения контекста между потоками
    \item Ограничений пропускной способности памяти
\end{itemize}

\section{Описание программы}

\subsection{Структура программы}

Программа состоит из следующих модулей:

\begin{itemize}
    \item \texttt{main.cpp} — главная программа, обработка параметров командной строки
    \item \texttt{median\_filter.h} — заголовочный файл с объявлениями классов
    \item \texttt{median\_filter.cpp} — реализация медианного фильтра с многопоточностью
    \item \texttt{common/comm.h} — система логирования
    \item \texttt{common/defines.h} — общие определения и подключение Windows API
    \item \texttt{common/errors.h/cpp} — обработка ошибок и ассерты
\end{itemize}

\subsection{Основные классы и структуры данных}

\textbf{Класс Matrix:}
\begin{itemize}
    \item Представляет двумерную матрицу целых чисел
    \item Методы: \texttt{at(row, col)} — доступ к элементу
    \item \texttt{loadFromFile()} — загрузка из файла
    \item \texttt{generateRandom()} — генерация случайной матрицы
    \item \texttt{saveToFile()} — сохранение в файл
\end{itemize}

\textbf{Структура MedianFilterParams:}
\begin{itemize}
    \item \texttt{window\_size} — размер окна фильтра (например, 3 для окна 3×3)
    \item \texttt{iterations} — количество применений фильтра (K)
    \item \texttt{max\_threads} — максимальное количество потоков
\end{itemize}

\textbf{Класс MedianFilter:}
\begin{itemize}
    \item \texttt{apply()} — применяет фильтр K раз к матрице
    \item \texttt{applySingleIteration()} — одна итерация фильтра
    \item \texttt{computeMedian()} — вычисление медианы для одного элемента
    \item \texttt{processRows()} — статическая функция для потока
\end{itemize}

\textbf{Структура ThreadTask:}
\begin{itemize}
    \item Содержит данные для каждого потока
    \item Указатели на входную и выходную матрицы
    \item Диапазон строк (\texttt{start\_row}, \texttt{end\_row})
    \item Указатель на объект фильтра
\end{itemize}

\subsection{Используемые системные вызовы Windows API}

\textbf{CreateThread():}
\begin{lstlisting}[language=C++]
HANDLE CreateThread(
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    SIZE_T dwStackSize,
    LPTHREAD_START_ROUTINE lpStartAddress,
    LPVOID lpParameter,
    DWORD dwCreationFlags,
    LPDWORD lpThreadId
);
\end{lstlisting}

Создает новый поток выполнения в адресном пространстве процесса. Возвращает дескриптор потока типа \texttt{HANDLE}.

\textbf{WaitForMultipleObjects():}
\begin{lstlisting}[language=C++]
DWORD WaitForMultipleObjects(
    DWORD nCount,
    const HANDLE* lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds
);
\end{lstlisting}

Блокирует выполнение текущего потока до завершения указанных потоков. При \texttt{bWaitAll = TRUE} ожидает завершения всех потоков.

\textbf{CloseHandle():}
\begin{lstlisting}[language=C++]
BOOL CloseHandle(HANDLE hObject);
\end{lstlisting}

Закрывает дескриптор объекта и освобождает связанные с ним ресурсы.

\subsection{Алгоритм работы программы}

\begin{enumerate}
    \item Парсинг параметров командной строки
    \item Загрузка матрицы из файла или генерация случайной
    \item Для каждой из K итераций:
    \begin{enumerate}
        \item Создание выходной матрицы
        \item Разделение строк матрицы между потоками
        \item Создание массива структур \texttt{ThreadTask}
        \item Создание $N$ потоков с помощью \texttt{CreateThread()}
        \item Ожидание завершения всех потоков (\texttt{WaitForMultipleObjects()})
        \item Закрытие дескрипторов потоков (\texttt{CloseHandle()})
        \item Выходная матрица становится входной для следующей итерации
    \end{enumerate}
    \item Сохранение результата и вывод статистики
\end{enumerate}

\subsection{Функция потока}

Каждый поток выполняет функцию \texttt{processRows()}:

\begin{lstlisting}[language=C++]
DWORD WINAPI MedianFilter::processRows(LPVOID param) {
    ThreadTask* task = static_cast<ThreadTask*>(param);
    
    for (size_t row = task->start_row; row < task->end_row; ++row) {
        for (size_t col = 0; col < task->input->cols(); ++col) {
            int median = task->filter->computeMedian(
                *task->input, row, col
            );
            task->output->at(row, col) = median;
        }
    }
    
    return 0;
}
\end{lstlisting}

Функция обрабатывает только свой диапазон строк, что исключает конфликты записи между потоками.

\subsection{Вычисление медианы}

Алгоритм вычисления медианы для элемента $(i, j)$:

\begin{enumerate}
    \item Создается вектор для хранения значений окна
    \item Для всех элементов в окне $w \times w$:
    \begin{itemize}
        \item Проверяются границы матрицы
        \item Значение добавляется в вектор
    \end{itemize}
    \item Применяется \texttt{std::nth\_element()} для поиска медианы за $O(n)$
    \item Для четного количества элементов берется среднее двух центральных
\end{enumerate}

\subsection{Параметры командной строки}

\begin{itemize}
    \item \texttt{-f <файл>} — входной файл с матрицей
    \item \texttt{-g <rows> <cols>} — генерация случайной матрицы
    \item \texttt{-w <размер>} — размер окна фильтра (должен быть нечетным)
    \item \texttt{-k <число>} — количество итераций
    \item \texttt{-t <число>} — максимальное количество потоков
    \item \texttt{-o <файл>} — выходной файл
    \item \texttt{-p} — вывести результат на экран
\end{itemize}

\subsection{Мониторинг потоков в Windows}

Для демонстрации количества используемых потоков можно использовать:

\textbf{Task Manager:}
\begin{itemize}
    \item Открыть Task Manager (Ctrl+Shift+Esc)
    \item Вкладка <<Подробности>>
    \item Найти процесс median\_filter.exe
    \item Добавить столбец <<Потоки>>
\end{itemize}

\textbf{PowerShell:}
\begin{lstlisting}[language=bash]
Get-Process -Name median_filter | 
    Select-Object -ExpandProperty Threads
\end{lstlisting}

\subsection{Формат входного файла}

Первая строка содержит размеры матрицы: \texttt{<rows> <cols>}

Далее идет матрица построчно:
\begin{lstlisting}
10 10
150 200 180 190 210 160 170 200 190 180
180 160 170 180 160 150 180 170 160 170
...
\end{lstlisting}

