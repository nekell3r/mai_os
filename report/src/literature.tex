\section{Исходная программа}

\subsection{Вспомогательные модули (common)}

\subsubsection{comm.h}

\lstinputlisting[language=C++,caption=comm.h,basicstyle=\tiny\ttfamily]{inc/comm.h}

\subsubsection{defines.h}

\lstinputlisting[language=C++,caption=defines.h,basicstyle=\tiny\ttfamily]{inc/defines.h}

\subsubsection{errors.h}

\lstinputlisting[language=C++,caption=errors.h,basicstyle=\tiny\ttfamily]{inc/errors.h}

\subsection{Основные модули}

\subsubsection{median\_filter.h}

\lstinputlisting[language=C++,caption=median\_filter.h,basicstyle=\small\ttfamily]{inc/median_filter.h}

\subsubsection{median\_filter.cpp}

\lstinputlisting[language=C++,caption=median\_filter.cpp,basicstyle=\small\ttfamily]{inc/median_filter.cpp}

\subsubsection{main.cpp}

\lstinputlisting[language=C++,caption=main.cpp,basicstyle=\small\ttfamily]{inc/main.cpp}

\subsection{Тестовый запуск программы}

Программа была запущена с параметрами для обработки матрицы 100×100 медианным фильтром с окном 3×3 за 1 итерацию, используя 4 потока.

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab2\build\src> .\median_filter.exe -g 100 100 -w 3 -k 1 -t 4
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
==============================================
  Median Filter with Multithreading
  Windows version
==============================================

Filter parameters:
  Window size: 3x3
  Iterations: 1
  Max threads: 4

Starting median filter application...

==============================================
Execution Statistics:
  Total time: 63.25 ms
  Average iteration time: 63.25 ms
  Threads used: 4
==============================================

Matrix saved to output_matrix.txt
\end{verbatim}

Программа успешно создала 4 рабочих потока и обработала матрицу за ~63 мс. Именно этот запуск использовался для трассировки системных вызовов в WinDbg.

\subsection{Трассировка системных вызовов (WinDbg)}

Для демонстрации использования системных вызовов Windows API программа была запущена под отладчиком WinDbg с установленными breakpoints на ключевые функции.

\subsubsection{Команды WinDbg}

\begin{verbatim}
windbgx.exe median_filter.exe -g 100 100 -w 3 -k 1 -t 4
.logopen D:\programming_projects\mai_os\lab2\build\src\trace.log
bu ntdll!NtCreateThreadEx
bu KERNELBASE!CreateThread
bu KERNELBASE!WaitForMultipleObjects
bu KERNELBASE!CloseHandle
g
\end{verbatim}

\subsubsection{Результаты трассировки (фрагменты)}

\textbf{Создание 4 потоков:}

\begin{verbatim}
Breakpoint 33 hit
KERNEL32!CreateThreadStub:
00007ffa`448c3100 4c8bdc          mov     r11,rsp

Breakpoint 0 hit
ntdll!NtCreateThreadEx:
00007ffa`464835c0 4c8bd1          mov     r10,rcx

Breakpoint 33 hit
KERNEL32!CreateThreadStub:
00007ffa`448c3100 4c8bdc          mov     r11,rsp

Breakpoint 0 hit
ntdll!NtCreateThreadEx:
00007ffa`464835c0 4c8bd1          mov     r10,rcx

Breakpoint 33 hit
KERNEL32!CreateThreadStub:
00007ffa`448c3100 4c8bdc          mov     r11,rsp

Breakpoint 0 hit
ntdll!NtCreateThreadEx:
00007ffa`464835c0 4c8bd1          mov     r10,rcx

Breakpoint 33 hit
KERNEL32!CreateThreadStub:
00007ffa`448c3100 4c8bdc          mov     r11,rsp

Breakpoint 0 hit
ntdll!NtCreateThreadEx:
00007ffa`464835c0 4c8bd1          mov     r10,rcx
\end{verbatim}

\textbf{Ожидание завершения всех потоков:}

\begin{verbatim}
Breakpoint 35 hit
KERNELBASE!WaitForMultipleObjects:
00007ffa`434ae680 4883ec38        sub     rsp,38h
\end{verbatim}

\textbf{Закрытие дескрипторов потоков (4 раза):}

\begin{verbatim}
Breakpoint 36 hit
KERNELBASE!CloseHandle:
00007ffa`434b26f0 4053            push    rbx

Breakpoint 36 hit
KERNELBASE!CloseHandle:
00007ffa`434b26f0 4053            push    rbx

Breakpoint 36 hit
KERNELBASE!CloseHandle:
00007ffa`434b26f0 4053            push    rbx

Breakpoint 36 hit
KERNELBASE!CloseHandle:
00007ffa`434b26f0 4053            push    rbx
\end{verbatim}

\subsubsection{Анализ трассировки}

Трассировка подтверждает следующую последовательность системных вызовов:

\begin{enumerate}
    \item \textbf{CreateThread} (через KERNEL32!CreateThreadStub) вызывается \textbf{4 раза} для создания рабочих потоков
    \item \textbf{NtCreateThreadEx} (низкоуровневый системный вызов в ядро) вызывается \textbf{4 раза} — по разу для каждого потока
    \item \textbf{WaitForMultipleObjects} вызывается \textbf{1 раз} для ожидания завершения всех 4 потоков
    \item \textbf{CloseHandle} вызывается \textbf{4 раза} для освобождения дескрипторов потоков
\end{enumerate}

Это полностью соответствует архитектуре программы и варианту задания (медианный фильтр с многопоточной обработкой).

\subsection{Системные вызовы Windows API}

\subsubsection{CreateThread}

Создает новый поток в адресном пространстве процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{lpThreadAttributes} = nullptr (безопасность по умолчанию)
    \item \texttt{dwStackSize} = 0 (размер стека по умолчанию)
    \item \texttt{lpStartAddress} = processRows (точка входа)
    \item \texttt{lpParameter} = \&tasks[i] (параметр потока)
    \item \texttt{dwCreationFlags} = 0 (запустить немедленно)
    \item \texttt{lpThreadId} = nullptr (ID не требуется)
\end{itemize}

\subsubsection{WaitForMultipleObjects}

Ожидает завершения одного или нескольких объектов синхронизации.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{nCount} = 4 (количество дескрипторов)
    \item \texttt{lpHandles} = threads.data() (массив дескрипторов)
    \item \texttt{bWaitAll} = TRUE (ждать завершения ВСЕХ)
    \item \texttt{dwMilliseconds} = INFINITE (без таймаута)
\end{itemize}

\subsubsection{CloseHandle}

Закрывает дескриптор объекта ядра (в данном случае — потока).

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{hObject} = threads[i] (дескриптор потока)
\end{itemize}
