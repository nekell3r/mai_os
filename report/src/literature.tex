\section{Исходная программа}

\subsection{Интерфейсы}

\subsubsection{integral\_interface.h}

\lstinputlisting[language=C++,caption=integral\_interface.h,basicstyle=\tiny\ttfamily]{inc/integral_interface.h}

\subsubsection{sort\_interface.h}

\lstinputlisting[language=C++,caption=sort\_interface.h,basicstyle=\tiny\ttfamily]{inc/sort_interface.h}

\subsection{Реализации динамических библиотек}

\subsubsection{rectangles.cpp}

\lstinputlisting[language=C++,caption=rectangles.cpp,basicstyle=\small\ttfamily]{inc/rectangles.cpp}

\subsubsection{trapezoids.cpp}

\lstinputlisting[language=C++,caption=trapezoids.cpp,basicstyle=\small\ttfamily]{inc/trapezoids.cpp}

\subsection{Тестовые программы}

\subsubsection{program1.cpp}

\lstinputlisting[language=C++,caption=program1.cpp,basicstyle=\small\ttfamily]{inc/program1.cpp}

\subsubsection{program2.cpp}

\lstinputlisting[language=C++,caption=program2.cpp,basicstyle=\small\ttfamily]{inc/program2.cpp}

\subsection{Тестовый запуск программы}

\subsubsection{Program 1 (Статическая линковка)}

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab4\build> .\program1.exe
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
=== Program 1: Static Linking ===
Using: rectangles implementation (statically linked)
  - SinIntegral: Rectangle method
  - Sort: Bubble Sort
Commands:
  1 <A> <B> <e>  - Calculate integral of sin(x) on [A, B] with step e
  2 <num1> <num2> ... <numN>  - Sort array
  exit  - Exit program

> 1 0 3.14159 0.1
23-56-59MSG program1 Integral of sin(x) on [0, 3.14159] with step 0.1 (Rectangle method):
Result: 2.000830
> 2 5 2 8 1 3
23-56-59MSG program1 Input array (Bubble Sort):
5 2 8 1 3
23-56-59MSG program1 Sorted array:
1 2 3 5 8
> exit
23-56-59MSG program1 Exiting...
\end{verbatim}

Программа успешно использует статически слинкованные функции. Код обеих функций включен в исполняемый файл на этапе компиляции.

\subsubsection{Program 2 (Динамическая загрузка)}

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab4\build> .\program2.exe
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
=== Program 2: Dynamic Loading ===
Commands:
  0  - Switch between rectangles.dll and trapezoids.dll
  1 <A> <B> <e>  - Calculate integral of sin(x) on [A, B] with step e
  2 <num1> <num2> ... <numN>  - Sort array
  exit  - Exit program

23-56-59MSG program2 Library loaded: rectangles.dll
> 1 0 3.14159 0.1
23-56-59MSG program2 Integral of sin(x) on [0, 3.14159] with step 0.1 (Rectangle method):
Result: 2.000830
> 2 5 2 8 1 3
23-56-59MSG program2 Input array (Bubble Sort):
5 2 8 1 3
23-56-59MSG program2 Sorted array:
1 2 3 5 8
> 0
23-56-59MSG program2 Library unloaded
23-56-59MSG program2 Library loaded: trapezoids.dll
23-56-59MSG program2 Switched to: Trapezoidal method / QuickSort
> 1 0 3.14159 0.1
23-56-59MSG program2 Integral of sin(x) on [0, 3.14159] with step 0.1 (Trapezoidal method):
Result: 1.998330
> 2 5 2 8 1 3
23-56-59MSG program2 Input array (QuickSort (Hoare)):
5 2 8 1 3
23-56-59MSG program2 Sorted array:
1 2 3 5 8
> exit
23-56-59MSG program2 Exiting...
\end{verbatim}

Программа успешно загружает DLL во время выполнения, переключается между реализациями и использует функции через указатели.

\subsection{Трассировка системных вызовов (WinDbg)}

Для демонстрации использования системных вызовов Windows API программы были запущены под отладчиком WinDbg с установленными breakpoints на ключевые функции уровня NTDLL (Native API).

\subsubsection{Команды WinDbg для Program 1}

\begin{verbatim}
cd lab4\build
windbg .\program1.exe

.reload
ld ntdll

# DLL Loading (Native API - NTDLL) - для сравнения
bp ntdll!LdrLoadDll ".echo === [LOAD] LdrLoadDll (LoadLibraryA) ===; g"
bp ntdll!LdrGetProcedureAddress ".echo === [PROC] LdrGetProcedureAddress (GetProcAddress) ===; g"
bp ntdll!LdrUnloadDll ".echo === [FREE] LdrUnloadDll (FreeLibrary) ===; g"

# I/O
bp ntdll!NtReadFile ".echo === [READ] NtReadFile (console input) ===; g"
bp ntdll!NtWriteFile ".echo === [WRITE] NtWriteFile (console output) ===; g"

.logopen trace_lab4_program1.log
g
\end{verbatim}

\subsubsection{Команды WinDbg для Program 2}

\begin{verbatim}
cd lab4\build
windbg .\program2.exe

.reload
ld ntdll

# DLL Loading (Native API - NTDLL)
bp ntdll!LdrLoadDll ".echo === [LOAD] LdrLoadDll (LoadLibraryA) ===; g"
bp ntdll!LdrGetProcedureAddress ".echo === [PROC] LdrGetProcedureAddress (GetProcAddress) ===; g"
bp ntdll!LdrUnloadDll ".echo === [FREE] LdrUnloadDll (FreeLibrary) ===; g"

# Memory mapping для DLL
bp ntdll!NtOpenSection ".echo === [OPEN] NtOpenSection (DLL) ===; g"
bp ntdll!NtMapViewOfSection ".echo === [MAP] NtMapViewOfSection (DLL) ===; g"
bp ntdll!NtUnmapViewOfSection ".echo === [UNMAP] NtUnmapViewOfSection (DLL) ===; g"

# I/O
bp ntdll!NtReadFile ".echo === [READ] NtReadFile (console input) ===; g"
bp ntdll!NtWriteFile ".echo === [WRITE] NtWriteFile (console output) ===; g"

# Cleanup
bp ntdll!NtClose ".echo === [CLOSE] NtClose ===; g"

.logopen trace_lab4_program2.log
g
\end{verbatim}

\subsubsection{Результаты трассировки Program 1}

Ниже представлен фрагмент лога с ключевыми системными вызовами (повторяющиеся строки сокращены):

\begin{verbatim}
... (initialization - загрузка системных DLL: advapi32.dll, msvcrt.dll, 
     sechost.dll, RPCRT4.dll и др.) ...

=== [WRITE] NtWriteFile (console output) ===
... (вывод приветственного сообщения) ...

# User input: "1 0 3.14159 0.1" (integral)
=== [READ] NtReadFile (console input) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Integral of sin(x)...") ...
... (calculation happens in DLL code - без системных вызовов) ...
=== [WRITE] NtWriteFile (console output) ===

# User input: "2 5 2 8 1 3" (sort array)
=== [READ] NtReadFile (console input) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Input array...") ...
... (sorting happens in DLL code - без системных вызовов) ...
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Sorted array...") ...
\end{verbatim}

\textbf{Ключевое наблюдение:} В логе Program 1 НЕ будет вызовов \texttt{LdrLoadDll} и \texttt{LdrGetProcedureAddress} для пользовательских библиотек, так как код статически слинкован на этапе компиляции. Это демонстрирует ключевое отличие статической линковки.

\subsubsection{Результаты трассировки Program 2}

Ниже представлен фрагмент лога с ключевыми системными вызовами (повторяющиеся строки сокращены):

\begin{verbatim}
... (initialization - загрузка системных DLL: advapi32.dll, msvcrt.dll, 
     sechost.dll, RPCRT4.dll и др.) ...

=== [WRITE] NtWriteFile (console output) ===
... (вывод приветственного сообщения) ...

# Initial DLL load (rectangles.dll)
=== [LOAD] LdrLoadDll (LoadLibraryA) ===
=== [OPEN] NtOpenSection (DLL) ===
=== [MAP] NtMapViewOfSection (DLL) ===
ModLoad: 00007ffe`9fd60000 00007ffe`9fd81000   
        D:\programming_projects\mai_os\lab4\build\rectangles.dll
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Library loaded: rectangles.dll") ...

# User input: "1 0 3.14159 0.1" (integral)
=== [READ] NtReadFile (console input) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Integral of sin(x)...") ...
... (calculation happens in DLL code - без системных вызовов) ...
=== [WRITE] NtWriteFile (console output) ===

# User input: "2 5 2 8 1 3" (sort array)
=== [READ] NtReadFile (console input) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Input array...") ...
... (sorting happens in DLL code - без системных вызовов) ...
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Sorted array...") ...

# User input: "0" (switch DLL)
=== [READ] NtReadFile (console input) ===
=== [FREE] LdrUnloadDll (FreeLibrary) ===
=== [UNMAP] NtUnmapViewOfSection (DLL) ===
=== [CLOSE] NtClose ===
=== [LOAD] LdrLoadDll (LoadLibraryA) ===
=== [OPEN] NtOpenSection (DLL) ===
=== [MAP] NtMapViewOfSection (DLL) ===
ModLoad: 00007ffe`a9ec0000 00007ffe`a9ee1000   
        D:\programming_projects\mai_os\lab4\build\trapezoids.dll
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [PROC] LdrGetProcedureAddress (GetProcAddress) ===
=== [WRITE] NtWriteFile (console output) ===
... (вывод "Switched to: Trapezoidal method / QuickSort") ...
\end{verbatim}

\subsubsection{Анализ трассировки}

Трассировка подтверждает следующую последовательность системных вызовов:

\textbf{Фаза 1: Инициализация процесса}
\begin{enumerate}
    \item Загрузка системных DLL (advapi32.dll, msvcrt.dll, sechost.dll, RPCRT4.dll и др.) через \texttt{LdrLoadDll}
    \item Множественные вызовы \texttt{NtOpenSection} и \texttt{NtMapViewOfSection} для маппинга системных библиотек
    \item Вывод приветственного сообщения через \texttt{NtWriteFile}
\end{enumerate}

\textbf{Фаза 2: Загрузка пользовательской DLL (rectangles.dll) — только Program 2}
\begin{enumerate}
    \item \textbf{LdrLoadDll} — загрузка DLL в память процесса (вызывается из \texttt{LoadLibraryA()})
    \item \textbf{NtOpenSection} — открытие секции DLL в системной памяти
    \item \textbf{NtMapViewOfSection} — отображение DLL в адресное пространство процесса (видно ModLoad сообщение)
    \item \textbf{LdrGetProcedureAddress} — получение адреса функции \texttt{SinIntegral} (вызывается из \texttt{GetProcAddress()})
    \item \textbf{LdrGetProcedureAddress} — получение адреса функции \texttt{Sort} (вызывается из \texttt{GetProcAddress()})
    \item Множественные \texttt{NtClose} — закрытие дескрипторов, созданных при загрузке
\end{enumerate}

\textbf{Фаза 3: Выполнение функций}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды и аргументов из консоли
    \item \textbf{NtWriteFile} — вывод входных данных
    \item \textbf{Выполнение кода} — происходит в коде DLL без дополнительных системных вызовов (обычный код в адресном пространстве процесса)
    \item \textbf{NtWriteFile} — вывод результата
\end{enumerate}

\textbf{Фаза 4: Переключение DLL (команда "0") — только Program 2}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды из консоли
    \item \textbf{LdrUnloadDll} — выгрузка текущей DLL (вызывается из \texttt{FreeLibrary()})
    \item \textbf{NtUnmapViewOfSection} — отмена отображения DLL из памяти
    \item \textbf{NtClose} — закрытие дескрипторов
    \item Повторение фазы 2 для загрузки \texttt{trapezoids.dll}
\end{enumerate}

\textbf{Фаза 5: Завершение (команда "exit")}
\begin{enumerate}
    \item \textbf{NtReadFile} — чтение команды выхода
    \item \textbf{LdrUnloadDll} — выгрузка DLL (только Program 2)
    \item \textbf{NtUnmapViewOfSection} — отмена отображения DLL (только Program 2)
    \item \textbf{NtClose} — закрытие всех дескрипторов
    \item \textbf{NtWriteFile} — вывод сообщения о завершении
\end{enumerate}

\subsubsection{Ключевые наблюдения}

\begin{enumerate}
    \item \textbf{Загрузка DLL:} Процесс загрузки DLL включает несколько системных вызовов:
    \begin{itemize}
        \item \texttt{LdrLoadDll} — основная функция загрузки
        \item \texttt{NtOpenSection} — открытие секции DLL
        \item \texttt{NtMapViewOfSection} — маппинг DLL в память
        \item \texttt{LdrGetProcedureAddress} — получение адреса функции (дважды — для SinIntegral и Sort)
    \end{itemize}
    Это больше системных вызовов, чем при статической линковке (где все разрешается на этапе компиляции).
    
    \item \textbf{Выполнение кода DLL:} После загрузки DLL код выполняется напрямую в адресном пространстве процесса. Вычисление интеграла и сортировка массива не требуют дополнительных системных вызовов — это обычный пользовательский код.
    
    \item \textbf{Переключение DLL:} При переключении между библиотеками происходит полная выгрузка одной DLL и загрузка другой. Это включает:
    \begin{itemize}
        \item Вызов \texttt{LdrUnloadDll} для выгрузки
        \item Вызов \texttt{NtUnmapViewOfSection} для отмены маппинга
        \item Повторение процесса загрузки для новой DLL
    \end{itemize}
    
    \item \textbf{Инициализация процесса:} В начале работы программы загружается множество системных DLL (advapi32.dll, msvcrt.dll и др.). Это нормальное поведение Windows при запуске любого процесса.
    
    \item \textbf{Сравнение со статической линковкой:} При статической линковке (Program 1) все эти системные вызовы для пользовательских библиотек отсутствуют — код обеих функций уже включен в .exe файл. Это видно по отсутствию вызовов \texttt{LdrLoadDll} и \texttt{LdrGetProcedureAddress} для пользовательских библиотек в Program 1.
\end{enumerate}

\subsection{Системные вызовы Windows API}

\subsubsection{LoadLibraryA() / LdrLoadDll()}

Загружает DLL в адресное пространство процесса.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
HMODULE LoadLibraryA(LPCSTR lpLibFileName);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrLoadDll(
    PWSTR DllPath,
    PULONG DllCharacteristics,
    PUNICODE_STRING DllName,
    PVOID *BaseAddress
);
\end{lstlisting}

\textbf{Процесс загрузки:}
\begin{enumerate}
    \item Поиск DLL в системных путях и текущей директории
    \item Открытие секции DLL через \texttt{NtOpenSection}
    \item Маппинг DLL в память через \texttt{NtMapViewOfSection}
    \item Выполнение инициализации DLL (DllMain, если есть)
    \item Возврат handle модуля
\end{enumerate}

\subsubsection{GetProcAddress() / LdrGetProcedureAddress()}

Получает адрес экспортируемой функции из загруженной DLL.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
FARPROC GetProcAddress(
    HMODULE hModule,
    LPCSTR lpProcName
);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrGetProcedureAddress(
    HMODULE ModuleHandle,
    PANSI_STRING FunctionName,
    WORD Ordinal,
    PVOID *FunctionAddress
);
\end{lstlisting}

\textbf{Процесс поиска:}
\begin{enumerate}
    \item Поиск функции в таблице экспорта DLL
    \item Проверка имени функции или порядкового номера
    \item Возврат адреса функции в памяти
\end{enumerate}

\subsubsection{FreeLibrary() / LdrUnloadDll()}

Выгружает DLL из памяти процесса.

\textbf{Высокоуровневый API:}
\begin{lstlisting}[language=C++]
BOOL FreeLibrary(HMODULE hLibModule);
\end{lstlisting}

\textbf{Низкоуровневый вызов (NTDLL):}
\begin{lstlisting}[language=C++]
NTSTATUS LdrUnloadDll(HMODULE ModuleHandle);
\end{lstlisting}

\textbf{Процесс выгрузки:}
\begin{enumerate}
    \item Выполнение финализации DLL (DllMain с флагом DLL\_PROCESS\_DETACH, если есть)
    \item Отмена маппинга через \texttt{NtUnmapViewOfSection}
    \item Закрытие дескрипторов через \texttt{NtClose}
    \item Освобождение памяти
\end{enumerate}

\subsubsection{NtMapViewOfSection()}

Отображает секцию (включая DLL) в адресное пространство процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{SectionHandle} — handle секции (DLL)
    \item \texttt{ProcessHandle} — handle процесса (текущий процесс)
    \item \texttt{BaseAddress} — базовый адрес для маппинга
    \item \texttt{ViewSize} — размер отображаемой области
    \item \texttt{Protect} — права доступа (PAGE\_EXECUTE\_READ для DLL)
\end{itemize}

\subsubsection{NtUnmapViewOfSection()}

Отменяет отображение секции из адресного пространства процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{ProcessHandle} — handle процесса
    \item \texttt{BaseAddress} — базовый адрес отображенной секции
\end{itemize}
