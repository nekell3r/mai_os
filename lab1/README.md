# Лабораторная работа №1 - Вариант 10

## Описание задания

Программа реализует межпроцессное взаимодействие между родительским и дочерним процессами через pipe (каналы) на Windows.

### Алгоритм работы:

1. **Родительский процесс:**
   - Запрашивает у пользователя имя файла
   - Открывает файл для чтения
   - Читает из файла команды вида `число<endline>`
   - Отправляет числа дочернему процессу через pipe
   - Получает ответы от дочернего процесса

2. **Дочерний процесс:**
   - Читает числа из stdin (перенаправленного на pipe)
   - Проверяет каждое число:
     - Если число **отрицательное** → завершает работу (и родитель тоже завершается)
     - Если число **простое** → завершает работу (и родитель тоже завершается)
     - Если число **составное** → отправляет его обратно родителю через stdout

## Структура проекта

```
lab1/
├── common/                 # Общие утилиты (по образцу base/)
│   ├── CMakeLists.txt
│   ├── defines.h           # Платформенные макросы
│   ├── comm.h              # Логирование (LogMsg, LogErr)
│   ├── errors.h            # Обработка ошибок
│   ├── errors.hpp          # Шаблоны для ошибок
│   └── errors.cpp          # Реализация DebugBreak
├── src/                    # Исходники программ
│   ├── CMakeLists.txt
│   ├── parent.cpp          # Родительский процесс
│   └── child.cpp           # Дочерний процесс
├── CMakeLists.txt          # Корневой файл сборки
├── test_numbers.txt        # Тестовый файл с числами
└── README.md               # Этот файл
```

## Требования

- **Windows 10/11**
- **CMake 3.10+**
- **Visual Studio 2019+** (или MinGW)
- **C++17**

## Компиляция и запуск

### Сборка через CMake:

```powershell
# Создаём директорию для сборки
mkdir build
cd build

# Вариант 1: Ninja (автоматически находит компилятор)
cmake .. -G Ninja
ninja

# Вариант 2: Visual Studio (если установлена)
# cmake .. -G "Visual Studio 17 2022"
# cmake --build . --config Release

# Вариант 3: MinGW
# cmake .. -G "MinGW Makefiles"
# cmake --build .
```

### Запуск:

```powershell
# Из директории build/src (где скомпилированы исполняемые файлы)
cd src
copy ..\..\test_numbers.txt .
echo test_numbers.txt | .\parent.exe

# Или просто:
.\parent.exe
# Введите имя файла: test_numbers.txt
```

При запуске программа попросит ввести имя файла:
```
Введите имя файла: test_numbers.txt
```

## Пример использования

### Тестовый файл `test_numbers.txt` содержит:
```
15
20
8
12
7
```

### Ожидаемый вывод:
```
Введите имя файла: test_numbers.txt
16-00-21MSG parent Читаю файл 'test_numbers.txt'
16-00-21MSG parent Отправляю число 15 дочернему процессу
16-00-21MSG parent Получено составное число 15 от дочернего процесса
16-00-21MSG parent Отправляю число 20 дочернему процессу
16-00-21MSG parent Получено составное число 20 от дочернего процесса
16-00-21MSG parent Отправляю число 8 дочернему процессу
16-00-21MSG parent Получено составное число 8 от дочернего процесса
16-00-21MSG parent Отправляю число 12 дочернему процессу
16-00-21MSG parent Получено составное число 12 от дочернего процесса
16-00-21MSG parent Отправляю число 7 дочернему процессу
16-00-21MSG parent Получен сигнал завершения от дочернего процесса
16-00-21MSG parent Дочерний процесс завершился с кодом 0
16-00-21MSG parent Завершение работы
```

**Примечание:** Сообщения от child процесса не видны в основном выводе, т.к. он работает в отдельном процессе со своим stdout/stderr.

## Windows API

Использованные Windows API функции:
- `CreateProcess()` — создание дочернего процесса
- `CreatePipe()` — создание неименованного канала для передачи данных
- `ReadFile()` / `WriteFile()` — чтение/запись данных через pipe
- `WaitForSingleObject()` — ожидание завершения дочернего процесса
- `GetExitCodeProcess()` — получение кода возврата процесса
- `CloseHandle()` — закрытие дескрипторов
- `GetStdHandle()` — получение стандартных дескрипторов

## Особенности реализации

1. **Структура по образцу base/**:
   - Модульная организация кода
   - Отдельная папка `common/` с утилитами
   - Отдельная папка `src/` с исполняемыми файлами
   - CMake для сборки каждого модуля

2. **Два pipe'а**:
   - `pipe_to_child` — для передачи чисел от родителя к ребёнку
   - `pipe_from_child` — для передачи результатов от ребёнка к родителю

3. **Правильное наследование дескрипторов**:
   - Создаются pipe'ы с `bInheritHandle = FALSE`
   - Через `SetHandleInformation()` явно указываем какие дескрипторы наследуются
   - Child наследует **только нужные** дескрипторы (stdin и stdout)
   - Ненужные дескрипторы остаются закрытыми в Child процессе

4. **Перенаправление потоков**:
   - Дочерний процесс получает stdin и stdout через `STARTUPINFO`
   - Используется `GetStdHandle()` для получения перенаправленных дескрипторов
   - stderr остаётся в консоли для отладки

5. **Логирование**:
   - Макросы `LogMsg()` и `LogErr()` с временными метками
   - Формат: `HH-MM-SS LEVEL CATEGORY MESSAGE`
   - `ASSERT_MSG()` для критических ошибок с подробным报ортом

6. **Обработка ошибок**:
   - Проверка всех системных вызовов через `ASSERT_MSG()`
   - Правильное закрытие дескрипторов (в parent и через наследование в child)
   - Информативные сообщения об ошибках с местоположением
   - `DebugBreak()` завершает программу через `exit(1)` (вызывает деструкторы)

## Диаграмма взаимодействия

```
┌──────────┐                              ┌──────────┐
│   User   │                              │   File   │
└────┬─────┘                              └────┬─────┘
     │ filename                                │
     │                                         │
     ▼                                         │
┌─────────────────┐                           │
│     Parent      │◄──────────────────────────┘
│   (parent.exe)  │         read numbers
└────────┬────────┘
         │
         │ CreateProcess()
         │ + STARTUPINFO with redirected handles
         │
         ├──────────────────────────────────┐
         │                                  │
         ▼                                  ▼
    ┌─────────┐                        ┌─────────┐
    │ pipe_to │                        │pipe_from│
    │  child  │                        │  child  │
    └────┬────┘                        └────▲────┘
         │                                  │
         │ WriteFile(number)                │ ReadFile(result)
         │                                  │
         ▼                                  │
    ┌─────────────────┐                    │
    │      Child      │                    │
    │   (child.exe)   │────────────────────┘
    │                 │     WriteFile(composite or -1)
    │  stdin = pipe   │
    │  stdout = pipe  │
    │  - check prime  │
    │  - check < 0    │
    └─────────────────┘
```

## Возможные проблемы и решения

### 1. child.exe не найден

**Проблема:** `Не удалось создать дочерний процесс`

**Решение:**
- Убедитесь, что `child.exe` находится в той же директории, что и `parent.exe`
- Проверьте, что оба файла скомпилированы в одной конфигурации (Release или Debug)

### 2. Файл test_numbers.txt не найден

**Проблема:** `Не удалось открыть файл`

**Решение:**
- Скопируйте `test_numbers.txt` в директорию с `parent.exe`
- Или укажите полный путь к файлу при запуске

### 3. Ошибки компиляции

**Проблема:** Ошибки при сборке

**Решение:**
- Убедитесь, что используете Visual Studio 2019+ или MinGW с поддержкой C++17
- Проверьте, что CMake правильно нашёл компилятор
- Запускайте CMake из "Developer Command Prompt for VS"

### 4. Предупреждения компилятора

Флаги `/W4 /WX` включают строгие предупреждения и превращают их в ошибки. Это помогает писать качественный код.

## Отличия от старой версии (на C с POSIX)

| Аспект | Старая версия | Новая версия |
|--------|---------------|--------------|
| Язык | C (POSIX) | C++ (Windows API) |
| API | `fork()`, `pipe()`, `execve()` | `CreateProcess()`, `CreatePipe()` |
| Платформа | Linux/Unix | Windows |
| Структура | Монолитные файлы | Модульная (common/ + src/) |
| Логирование | `printf()` / `fprintf()` | `LogMsg()` / `LogErr()` |
| Сборка | Makefile | CMake |

## Дополнительная информация

### Почему такая структура?

Структура проекта повторяет образец из `base/`, что является хорошей практикой:
- **Модульность**: разделение утилит и основного кода
- **Переиспользование**: `common/` можно использовать в других лабораторных
- **Масштабируемость**: легко добавлять новые модули
- **Профессионализм**: так организуются реальные проекты

### Логирование с временными метками

Макросы из `common/comm.h` автоматически добавляют временные метки ко всем сообщениям, что помогает отслеживать порядок событий при межпроцессном взаимодействии.

### Обработка ошибок

Макрос `ASSERT_MSG()` из `common/errors.h` позволяет создавать информативные сообщения об ошибках с указанием файла, строки и условия. При срабатывании ASSERT вызывается `exit(1)`, что гарантирует:
- Завершение программы
- Вызов деструкторов локальных объектов
- Закрытие файловых дескрипторов (pipe'ов)
- Освобождение всех ресурсов

### SetHandleInformation и наследование

Для чистоты кода и безопасности используется `SetHandleInformation()`:
- Создаём pipe'ы с `bInheritHandle = FALSE` (ничего не наследуется)
- Явно указываем какие дескрипторы должны наследоваться через `SetHandleInformation(handle, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT)`
- Child получает **только нужные** дескрипторы, ненужные остаются закрытыми
- Это избегает утечек ресурсов и deadlock'ов
