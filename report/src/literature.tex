\section{Исходная программа}

\subsection{Вспомогательные модули (common)}

\subsubsection{comm.h}

\lstinputlisting[language=C++,caption=comm.h,basicstyle=\tiny\ttfamily]{inc/comm.h}

\subsubsection{defines.h}

\lstinputlisting[language=C++,caption=defines.h,basicstyle=\tiny\ttfamily]{inc/defines.h}

\subsubsection{errors.h}

\lstinputlisting[language=C++,caption=errors.h,basicstyle=\tiny\ttfamily]{inc/errors.h}

\subsection{Основные модули}

\subsubsection{median\_filter.h}

\lstinputlisting[language=C++,caption=median\_filter.h,basicstyle=\small\ttfamily]{inc/median_filter.h}

\subsubsection{median\_filter.cpp}

\lstinputlisting[language=C++,caption=median\_filter.cpp,basicstyle=\small\ttfamily]{inc/median_filter.cpp}

\subsubsection{main.cpp}

\lstinputlisting[language=C++,caption=main.cpp,basicstyle=\small\ttfamily]{inc/main.cpp}

\subsection{Тестовый запуск программы}

Программа была запущена с параметрами для обработки матрицы 100×100 медианным фильтром с окном 3×3 за 1 итерацию, используя 4 потока.

\textbf{Команда запуска:}

\begin{verbatim}
D:\programming_projects\mai_os\lab2\build\src> .\median_filter.exe -g 100 100 -w 3 -k 1 -t 4
\end{verbatim}

\textbf{Вывод программы:}

\begin{verbatim}
==============================================
  Median Filter with Multithreading
  Windows version
==============================================

Filter parameters:
  Window size: 3x3
  Iterations: 1
  Max threads: 4

Starting median filter application...

==============================================
Execution Statistics:
  Total time: 63.25 ms
  Average iteration time: 63.25 ms
  Threads used: 4
==============================================

Matrix saved to output_matrix.txt
\end{verbatim}

Программа успешно создала 4 рабочих потока и обработала матрицу за ~63 мс. Именно этот запуск использовался для трассировки системных вызовов в WinDbg.

\subsection{Трассировка системных вызовов (WinDbg)}

Для демонстрации использования системных вызовов Windows API программа была запущена под отладчиком WinDbg с установленными breakpoints на ключевые функции уровня NTDLL (Native API).

\subsubsection{Команды WinDbg}

\begin{verbatim}
windbgx.exe median_filter.exe -g 100 100 -w 3 -k 1 -t 4
.logopen D:\programming_projects\mai_os\lab2\build\src\trace.log
bu ntdll!NtCreateThreadEx ".echo === NtCreateThreadEx (CreateThread) ===; g"
bu ntdll!NtWaitForMultipleObjects ".echo === NtWaitForMultipleObjects ===; g"
bu ntdll!NtClose ".echo NtClose; g"
bu ntdll!NtWriteFile ".echo NtWriteFile; g"
g
\end{verbatim}

\subsubsection{Результаты трассировки}

Ниже представлен фрагмент лога с ключевыми системными вызовами (NtClose и NtWriteFile от инициализации опущены для краткости):

\begin{verbatim}
... (загрузка модулей) ...

=== NtCreateThreadEx (CreateThread) ===
=== NtCreateThreadEx (CreateThread) ===
=== NtCreateThreadEx (CreateThread) ===
=== NtCreateThreadEx (CreateThread) ===
=== NtWaitForMultipleObjects ===
NtClose
NtClose
NtClose
NtClose

... (вывод результатов через NtWriteFile) ...

ntdll!NtTerminateProcess+0x14:
00007ffa`46482244 c3              ret
\end{verbatim}

\subsubsection{Анализ трассировки}

Трассировка подтверждает следующую последовательность системных вызовов:

\begin{enumerate}
    \item \textbf{NtCreateThreadEx} вызывается \textbf{4 раза подряд} (строки 113-116 полного лога) — это низкоуровневый системный вызов ядра Windows для создания потоков. Каждый вызов соответствует функции \texttt{CreateThread} из KERNEL32 API.
    
    \item \textbf{NtWaitForMultipleObjects} вызывается \textbf{1 раз} (строка 117) — главный поток блокируется до завершения всех 4 рабочих потоков. Это обертка для \texttt{WaitForMultipleObjects}.
    
    \item \textbf{NtClose} вызывается \textbf{4 раза подряд} (строки 118-121) сразу после завершения ожидания — освобождаются дескрипторы завершившихся потоков. Соответствует \texttt{CloseHandle}.
    
    \item \textbf{NtWriteFile} вызывается многократно для вывода статистики и логов в консоль.
\end{enumerate}

Последовательность полностью соответствует архитектуре программы: создание $\rightarrow$ ожидание $\rightarrow$ освобождение ресурсов.

\subsection{Системные вызовы Windows API}

\subsubsection{CreateThread}

Создает новый поток в адресном пространстве процесса.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{lpThreadAttributes} = nullptr (безопасность по умолчанию)
    \item \texttt{dwStackSize} = 0 (размер стека по умолчанию)
    \item \texttt{lpStartAddress} = processRows (точка входа)
    \item \texttt{lpParameter} = \&tasks[i] (параметр потока)
    \item \texttt{dwCreationFlags} = 0 (запустить немедленно)
    \item \texttt{lpThreadId} = nullptr (ID не требуется)
\end{itemize}

\subsubsection{WaitForMultipleObjects}

Ожидает завершения одного или нескольких объектов синхронизации.

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{nCount} = 4 (количество дескрипторов)
    \item \texttt{lpHandles} = threads.data() (массив дескрипторов)
    \item \texttt{bWaitAll} = TRUE (ждать завершения ВСЕХ)
    \item \texttt{dwMilliseconds} = INFINITE (без таймаута)
\end{itemize}

\subsubsection{CloseHandle}

Закрывает дескриптор объекта ядра (в данном случае — потока).

\textbf{Параметры:}
\begin{itemize}
    \item \texttt{hObject} = threads[i] (дескриптор потока)
\end{itemize}
